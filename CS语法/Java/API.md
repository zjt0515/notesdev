## 包装类

基本类型对应的引用类型，将数据包装成对象

> [!note]
>
> 为什么要有包装类？
>
> - 万物皆对象思想
> - 泛型和集合不支持基本类型，支持包装类



![image-20240511100731998](./images/image-20240511100731998.png)

String就是包装类

### 属性和方法

`.MIN/MAX_VALUE`封装数据范围

`equals()`方法被重写，比较的是内容

`==`比较的是地址

### (自动)拆箱和装箱

`Integer.valueof(20)`
自动装箱：基本类型自动转对应的包装类
即可以直接将基本类型赋值给对应的包装类对象

自动拆箱 ：引用类型自动转基本类型
直接将引用类型赋值给基本类型



> [!note]
>
> 通过字节码文件反编译：自动装箱和拆箱就是调用`Integer.valueof(20)`和`xx.intvalue()`

### 应用

基本类型转字符串

1. 拼接字符串
    `String s = num + "";`
2. toString，Integer类的静态方法或者其对象的方法
    `Integer.toString(num)`
    `integer.toString()`
3. 自动装箱，String类的静态方法
    `String.valueOf(num)`



字符串转基本类型

1. Integer类的静态方法
    `Integer.parseInt(str)`

2. 自动拆箱
    `Integer.valueOf(str)`

### 进阶：包装类的内存复用（常量池）

> 在程序运行时 -128 ~ 127的int值就被jvm装入常量池中。自动装箱时，对于Integer var = 5，如果var指向的对象在-128 至 127范围内的赋值时，生成的Integer实例化对象是由IntegerCache.cache()方法产生，它会复用已有对象。和String的常量池是一个道理，cache()方法会将位于-128~127范围内产生的Integer对象入池，下次使用的时候，从池中拿去，就不会在创建了。

>  所以，在这个数值区间内的 Integer对象的栈指向(属性名) 可以直接使用==进行判断，因为值相同，指向的就是同一片区域。但是这个区间之外的所有数据，自动装箱都会在堆上产生实例化，并不再复用已有对象，尤其要注意，为了避免这个问题，推荐使用equals 方法进行Integer值的比较判断。当然判断值和地址是否都相同，还是得用 ==。

> 除了两个包装类Long和Double 没有实现这个缓存技术，其它的包装类均实现了它。这是因为Long和Double类型的对象占用内存较大，不宜应用于常量池中，长时间占用内存。

```java
// -128~127自动装箱
int a = 127;
Integer A = a;
a==b //地址一样，true
// 以外的数据
int a = 128;
Integer A = a;
a==b //地址不一样，false

```





> [!caution]
>
> 字符串转基本数字类型，字符串不能出现非数字字符

> [!note]
>
> 总结
>
> 包装类提供的基本功能：字符串和基本类型相互转换