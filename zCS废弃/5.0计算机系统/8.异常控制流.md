

1. CPU控制流、异常控制流
2. 进程和进程上下文切换
3. 异常和中断的响应和处理
4. Linux中的进程控制

> 1. 可以理解并发
> 2. 可以帮助理解编写应用程序
> 3. 帮助理解软件异常

## 异常

### CPU控制流

> cpu执行的指令的地址序列



### 异常控制流

> 某些特殊情况引起用户程序的正常执行被打断所形成的意外控制流。
>
> 
>
> 1. 可以用于实现IO，进程和虚拟内存  
>
> 原因：
>
> 1. 内部异常(硬件层)
>     1. 缺页
>     2. 越权
>     3. 越级
>     4. 整除0
>     5. 溢出
> 2. 外部中断(硬件层)
>     1. ctrlc
>     2. 打印缺纸
>     3. DMA结束
> 3. 进程的上下文切换（操作系统层）
> 4. 一个进程直接发送信号给另一个进程





### 异常分类

| 异常 |      | 原因               | 返回行为         |
| ---- | ---- | ------------------ | ---------------- |
| 中断 | 异步 | 来自IO设备中断信号 | 总是返回下一条   |
| 陷阱 | 同步 | 有意的异常         | 总是返回下一条   |
| 故障 | 同步 | 潜在可恢复的错误   | 可能返回当前指令 |
| 终止 | 同步 | 不可恢复的错误     | 不会返回         |

### 中断

1. 可屏蔽中断：通过 INTR 向CPU请求，可通过设置屏蔽字来屏蔽请求，若中断请求被屏蔽，则不会被送到CPU。
2. 不可屏蔽中断： 非常紧急的硬件故障，如：电源掉电，硬件线路故障等。通过 NMI 向CPU请求。一旦产生，就被立即送CPU，以便快速处理。这种情况下，中断服务程序会尽快保存系统重要信息，然后在屏幕上显示相应的消息或直接重启系统。 

### 故障

执行指令引起的异常事件

1. 溢出
2. 非法指令
3. 缺页：补救后可继续执行
4. 访问越权

###  异常处理

系统进入OS内核态(处理器状态从用户态 → 内核态)，对相应事件处理

### 高级软件异常



## 进程与上下文

### 地址空间

假象

1. 程序独占的使用处理器
2. 独占的使用内存系统

> 并发流：一个逻辑流的执行在时间上与另一个流重叠的情况，他们是并发运行  
>
> 并行：两个进程在不同核心？上同时运行
>
> 并发是交替运行，并行是同时运行

`/proc`内核相关的数据结构

### 模式

### 上下文

进程调度：进程

进程抢占

> 程序：代码和数据，运行时以段的形式存在于地址空间
>
> 进程：执行中的程序的实例

### fork()

产生一份和父进程具有相同但独立的地址空间

- 相同：
- 独立： 

1. 在父进程返回 子进程的pid (总是 > 0)
2. 在子进程返回 0

### 





## 信号

运行内核和进程 中断其他进程

信号提供了机制：通知进程发生了什么异常情况

支持信号：

| Num  | Name | event |
| ---- | ---- | ----- |
| 1    |      |       |
| 2    |      |       |
| 3    |      |       |

### 信号传送过程

> 进程组：
>
> 每个进程只属于一个进程组
> 每个进程组有唯一ID标识，正整数
>
> ```c
> #include <unistd.h>
> // 获取id
> pid_t getpgrp(void);
> // 改变进程组，原来的进程组id → 更改后的进程组id
> pidt_t setpgrp(pid_t pid, pid_t pgid);
> // pid=15213，创建新进程组15213，包含的进程id也是15213
> setpgid(0,0)
> ```
>
> 子进程和父进程属于一个进程组，
>
> 前台进程组: 
>
> `ls | sort` ls和sort两个进程通过管道连接
>
> 最多有一个前台作业和任意个后台作业
>
> `ctrl+c`终止前台作业
>
> `ctrl+z`挂起前台作业

信号发送：

1. `/bin/kill -9 15213`向15213进程发送信号9（杀死进程
2. `/bin/kill -9 -15213`向进程组15213发送信号9
3. `ctrl+c/z...`
4. `函数kill(pid_t,)`
5. `alarm(unsigned int secs)`，secs秒后发送一个SIGALRM信号给调用进程



接受信号：

1. 进程终止
2. 进程终止并转储内存
3. 进程挂起，直到被SIGCONT信号重启
4. 进程忽略该信号

> 待处理信号：发出而没有被接受的信号
>
> 一个待处理信号最多只能被接受一次