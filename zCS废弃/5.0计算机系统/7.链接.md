# 链接

## 7-1. 编译器驱动程序

得到可执行程序：`gcc -Og -o prog main.c sum.c`
-Og优化，-o prog指定可执行文件名，



预处理：得到main.i文件
`cpp -o main.i main.c`
`gcc -E -o main.i main.c`

编译：
`cc -S -o main.s main.i`
`gcc -S -o main.s main mainl.i`

汇编：得到可重定位的目标文件main.o，sum.o
`as -o main.o main.s`

## 7-4. 可重定位目标文件

编译+汇编，不执行链接：`gcc -c main.c`

### ELF头

- ELF头：
    - 定义ELF魔数、目标文件的类型、小端/大端、版本、操
        作系统平台、机器结构类型、节头表的起始位置和长度等
    - <img src="./images/image-20240614232810785.png" alt="image-20240614232810785" style="zoom: 33%;" />

- Sections
- Section header table 节头部表

> ELF：可执行可链接格式

查看elf header具体内容`readelf -h main.o`

![image-20240614232848961](./images/image-20240614232848961.png)

### Section header table 节头部表

`readelf -S main.o`


1. Offset：section的起始位置
2. Size：section大小

### section 节

1. .text ：机器代码
2. .rodata ：只读数据
3. .data：已初始化的全局和静态变量 ，不包括0
4. .bss ：未初始化的全局变量、未初始化的静态变量和0
    1. 该节不占据实际空间，仅仅是占位符
    2. COMMON和bss的区别：COMMON是未初始化的全局变量，bss是未初始化的静态变量和0

5. 

剩余section

1. .comment 存放编译器版本信息
2. .symtab： 符号表 `readelf -s main.o`，函数和全局变量，不包括局部变量
   > [!note]
   >
   > <img src="./images/image-20240615125032055.png" alt="image-20240615125032055" style="zoom: 25%;" />
   >
   > Ndx：查询section header table
   >
   > value：相对于所在section起始位置的偏移量
3. .rel.text 重定位表
4. .debug： 调试信息
5. .line ：C源程序行号和.text节中的机器指令的映射
6. .strtab ：字符串表

> 局部变量既不在data中也不再bss中
> bss可以理解为better save space，
> 







## 7-5. 符号和符号表

目标模块m的符号类型：

1. 全局符号：m模块内定义的并能够被其他盘模块引用
2. 外部符号：其他模块定义并被m模块引用
3. 局部符号：static的函数和全局变量(只被m模块定义和引用)

> 使用static隐藏模块内部的变量和函数声明，static表名是模块私有的，不能被其他模块访问
>
> More：static变量不在栈中管理，编译器为其在data或bss中分配空间，并在符号表中创建唯一名字的本地链接器符号

## 7-6. 符号解析与静态库

### 符号解析

只对文件编译+汇编：`gcc -c xx.c`
当编译器遇到一个不在当前模块中定义的符号：编译器假设是在其他模块定义的

查看符号表`readelf -s xx.o`

链接生成可执行文件：`gcc -Wall -Og -o  xx xx.c`
找不到定义的符号：报错，终止链接



1. **强符号**：函数 + 初始化的全局变量
2. **弱符号**：未初始化的全局变量

> (多个可重定位文件中，定义了同名全局符号)
>
> 链接器如何解析多重定义的全局符号
>
> 1. 多个强符号重名
>     1. 链接器不允许多个同名的强符号同时出现，会报错
> 2. 1个强符号和多个同名弱符号：
>     1. 选择强符号，可以生成可执行文件，但可能会造成不易察觉的错误
> 3. 多个弱符号重名：
>     1. 任意选择一个，可以生成可执行文件，但会造成不易察觉的错误
>
> 如果重名符号不同类型：严重的隐藏错误
> 添加编译参数`-fno-common`遇到多重定义的全局符号报错
> `-Werror`把所有警告变为错误
>
> 
>
> 对于多重定义全局符号问题的建议：
>
> 1. 尽量避免使用全局变量
> 2. 尽量使用本地static变量
> 3. 全局变量要赋初值
> 4. 外部全局变量要使用extern
>
> ![image-20240620194641326](./images/image-20240620194641326.png)



### 链接器如何使用静态库

如何构造静态库：



示例

编译`gcc -c main.c`
在链接的时候加入静态库`gcc -static -o porg main.o ./libvector.a`
此时得到了可执行文件prog

链接器的链接流程：

1. 确定main.o引用了如addvec.o中定义的addvec
2. 从libvector复制addvec.o到可执行文件
3. 没有引用multvec.o中定义的符号，不复制模块
4. 还会从libc.a中复制printf.o等c runtime所需模块



### 静态库的解析过程，链接顺序

链接器使用静态库来解析引用的过程：

1. 从左到右按顺序扫描可重定位文件和静态库文件（main.o、libvector.a、libc.a
2. 判断是目标文件还是静态库文件
    1. 目标文件：存入集合E，修改U和D
    2. 静态库文件：存入集合E，寻找集合U中的符号，找到了就删除，如果有新的符号定义，放入D
3. 维护三个集合：
    1. 集合E：可重定位目标文件，最终合并形成可执行文件
    2. 集合U：引用但尚未定义
    3. 集合D：输入文件中已经定义的符号
4. 扫描文件完成，检查集合U
    1. U为空，合并集合E生成可执行文件
    2. U非空，报错终止

缺点：对文件顺序有要求，如果库文件在前面，可能有符号没有被解析到
库一般放在命令行结尾，如果库之间有调用，调用者的必须放在前面
如果库之间存在相互调用，同一个库必须重复出现1次 或者 合并成一个静态库文件

## 7-7. 重定位

合并输入模块，为每个符号分配运行时地址

1. 重定位节和符号定义
    1. ![image-20240620204356036](./images/image-20240620204356036.png)
2. 重定位节中的符号引用

### 重定位条目

重定位条目 ：汇编器生成可重定位目标文件，遇到最终位置不确定的符号引用(例如外部定义的)，就产生一个重定位条目
作用：用来告诉链接器在合成可执行文件时，如何修改这个引用
位置：

- 代码的重定位条目放在.rel .text中

- 已初始化数据的重定位条目放在.rel.data中



结构体定义格式：
```c++
typedef struct {
  long offset; // 被修改的引用的节偏移量
  long type:32, // 告诉链接器如何修改引用
       symbol:32;  // 被修改引用应该指向的符号
  long addend;  // 有符号常数，做偏移调整
}ELF64_Rela;
```

2种最基本重定位类型： 

- 相对地址的重定位
- 绝对地址的重定位



根据重定位条目确定操作码的后面是什么：（重定位相对引用

1. 计算引用的运行时地址：`ref_addr=ADDR(main)+r.offset`
2. 更新符号引用`ref_ptr=ADDR(sum) - ref_addr + r.addend`

![image-20240620211113850](./images/image-20240620211113850.png)

> PC的值：正在执行指令的下一条指令的地址



### 重定位绝对引用

![image-20240620211203556](./images/image-20240620211203556.png)

`ADDR(array)=0x601018 (.data setcion)`

`ref_ptr=ADDR(array) + r.addend`

![image-20240620211425164](./images/image-20240620211425164.png)





经过重定位后，就能确定目标文件中text和data中的内容，
程序执行加载时，加载器将section中的字节直接复制到内存中























## 7-8. 可执行目标文件

![image-20240621105857604](./images/image-20240621105857604.png)

文件格式

- .init： _init函数，调用进行初始化
- .text：
- .rodata：
- .data

### 程序头部表

描述代码段、数据段与内存的映射关系 















## 7-8. 动态链接共享库



## 7.12 位置无关代码



## 7-13. 库打桩机制

拦截库函数调用，对拦截信息做一定处理，再把请求转发到真正的库函数

可以做到：追踪对某个库函数的调用次数

### 编译时打桩

`gcc -DCOMPILETIME -c mymalloc.c`

`gcc -I. -o intc int.c mymalloc.o`

### 链接时打桩

### 运行时打桩



