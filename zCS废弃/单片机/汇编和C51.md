## 汇编语言编程

> 1. 汇编语言程序设计的基本步骤 
> Ø分析设计任务；
> Ø建立算法；
> Ø程序的总体设计及流程图的制定；
> Ø编写源程序；
> Ø源程序的汇编与调试；
> Ø编写文档资料。
> 1. 汇编语言程序设计的基本方法 
> Ø了解汇编语言源程序的基本结构；
> Ø模块化的程序设计方法；
> Ø自顶向下逐步求精的程序设计方法；
> Ø子程序化的程序设计方法。

### 汇编语言设计常用伪指令简介

伪指令又称汇编程序控制指令，属说明性汇编指令，用来对汇编过程进行某种控制，或者对符号、标号等赋值。伪指令和实际指令之间的不同是它在汇编时不会生成机器指令代码，只是在形式上和指令相似，因此称其为“伪指令”；
不同的单片机系列或开发系统所定义的伪指令不完全相同，程序设计者在使用这些工具进行编程前应首先参考其用户手册。MCS-51型单片机汇编语言中常见的伪指令包括：

![image-20250104150620834](./images/image-20250104150620834.png)

2. 汇编结束伪指令END
l格式：END
l功能：是源程序汇编结束的标志。在END之后所
写的任何内容(不管是指令、语句或其它内容)，汇
编程序都不予理会。一个源程序只能有一个END
伪指令，在同时包括主程序和子程序的汇编源程
序中，也只能有一个END伪指令。因此，END伪
指令应放在所有源程序的末尾。

![image-20250104153122107](./images/image-20250104153122107.png)

![image-20250104153128991](./images/image-20250104153128991.png)

![image-20250104153135198](./images/image-20250104153135198.png)

![image-20250104153142535](./images/image-20250104153142535.png)

![image-20250104153148532](./images/image-20250104153148532.png)

### 程序设计实例

> 和其它程序一样，单片机程序总是由以下几种基本的结构化程序块构成：
>
> 1. 顺序程序；
> 2. 分支程序；
> 3. 循环程序；
> 4. 子程序调用（可归入分支程序）；
> 5. 查表程序（可归入分支程序）。
>
> 顺序结构程序是指一种无分支的直线执行程序，即程序的执行是按照程序计数器PC递增的顺序，
> 从第一条指令开始逐条、顺序进行的；
>
> 顺序结构程序在整个程序设计中所占的比例最大，往往用来解决一些简单的算术即逻辑运算问题，主要使用数据传送、数据运算及逻辑运算类指令构成；
>
> 分支程序是利用条件转移指令，使程序根据执行过程中的条件或逻辑判断来改变程序执行的顺序，
> 从而选择不同的程序处理路径；
>
> 1. 设计分支程序的关键问题是如何判断分支条件；
> 2. MCS-51的指令系统提供了丰富的条件转移指令：
>     Ø累加器A判0条件转移指令（JZ/JNZ）
>     Ø比较条件转移指令（DJNZ/CJNE）
>     Ø位条件转移指令（JC/JNC、JB/JNB、JBC）等。
> 3. 通过这些指令，就可以完成各种各样的条件判断。注意，执行一条条件判断指令时，只能形成两路分支，如果需要多路分支，则需要进行多次判断。
>
> 分支程序可进一步分为：
>
> 1. 单分支程序：程序从两个分支中选择一个；
> 2. 多分支程序：程序需要从两个以上的出口中选择一个；
>
> 循环结构是控制程序多次执行同一功能的一种程序结构；
> 循环结构程序主要由4部分构成：
>
> 1. 初始化部分；
> 2. 循环处理部分；
> 3. 循环控制部分；
> 4. 结束处理部分。
>
> 循环结构中，循环初始化部分和结束处理部分一般只执行一次；
>
> 1. 循环处理部分和循环控制部分称为循环体，视情况可执行多次；
> 2. 具体循环执行的次数由循环控制部分决定；
> 3. 常见的循环控制方法有计数器控制和条件控制两种；
> 4. 循环结构还可进一步划分为：
>     1. 单重循环结构；
>     2. 多重循环结构。
>
> 循环程序设计中需要注意的几个问题:
>
> 1. 循环程序是在计数或条件控制变量的控制下执行的。循环应在控制条件不满足时退出，所以要避免从循环体外部直接跳转到循环体内部，以免干扰循环计数器或判断条件，引起程序的混乱。
> 2. 多重循环是由外向内一层层进入的，但在结束时则是由内向外一层层退出的。所以在循环嵌套程序中，不要在外层程序使用跳转指令直接跳转到内层循环体中。
> 3. 从循环体内部是可以使用跳转指令转移到循环体外或外层循环中，这实际上就是条件控制循环的结构。
> 4. 设计循环程序时，首先要确定循环的结构，从各层循环执行的顺序入手，依次分析各层循环的递进关系，最后确定各层循环的控制计数器初值或执行条件，使其成为一个完整的循环程序。

### 子程序设计

> 主程序和子程序
> Ø 被调用的程序称为子程序；
> Ø 调用子程序的程序称为主程序；
> l 子程序的嵌套调用
> Ø 子程序执行过程中再次调用其它子程序的现象称为子
> 程序嵌套调用；
> Ø 主程序调用子程序的下一条指令地址被称为断点；
> Ø 每个断点都必须进行现场保护；
> Ø MCS-51单片机的现场保护是通过将数据压入堆栈的方
> 式完成的；
> Ø 由于堆栈空间有限，因此子程序嵌套层数不可过多。

子程序调用过程

1. 主程序执行ACALL指令或LCALL指令调用子程序；
2. CPU执行保护断点工作，将紧接调用指令后的指令地址压入堆栈；
3. CPU执行被调用子程序；
4. 被调用子程序执行RET指令返回主程序；
5. CPU从堆栈弹出断点地址，主程序继续执行。

子程序的参数传递（主要有三种方法）
(1) 寄存器或累加器传递
Ø 使用累加器A或寄存器R0~R7传递参数；
Ø 优点：传递效率高，执行速度快；
Ø 缺点：受寄存器个数限制，传递参数不多。
(2) 存储区传递
Ø 将待传输数据存于一个存储区中，将存储区地址传递给子程序；
Ø 优点：类似指针传递，效率大大提高，可传递可变长参数，参数返回也可采用此方法；
Ø 缺点：无明显缺点。

(3) 堆栈传递
Ø 将待传输参数压入堆栈，调用子程序后，子程序移动堆栈指针取得传入的参数；
Ø 优点：传递效率高，执行速度快；
Ø 缺点：受堆栈空间的限制，传递参数个数受限。

子程序调用时现场的保护和恢复
Ø 子程序在执行前，由于主程序在调用完子程序后将继续执行，因此应将子程序可能用到的资源，包括工作寄存器R0～R7、RAM单元、A、DPTR、PSW等都压入堆栈保存，以免返回后主程序出错，这个过程称为现场保护；
Ø 在执行完子程序返回主程序之前，将被保护的内容恢复到原始单元中的过程称为现场恢复。

子程序调用时现场的保护和恢复有两种方法：

1. 子程序调用时现场的保护和恢复有两种方法：
2. 由子程序负责现场保护和恢复
    1. 这种方式由子程序决定如何保护和恢复现场，子程序规范、清晰，结构更合理。

```assembly
; 由主程序负责现场保护和恢复
......; 主程序
PUSHPSW; 将子程序中用到的资源
PUSHA; 入栈，保护现场
PUSH B
MOV PSW,#10H; 选择工作寄存器组2
CALL Sub; 由编译器决定如何调用
POP B; 恢复现场
POP A
POP PSW
......
```

```assembly
ORG xxxx; 子程序
Sub: PUSH PSW; 将子程序中用到的资源
PUSH A; 入栈，保护现场
PUSH B
MOV PSW,#10H; 选择工作寄存器组2
......; 子程序执行自身功能
POP B; 恢复现场
POP A
POP PSW
RET
```







## C51编程

### 数据类型

> 为了更加有利地利用8051的存储结构，C51引入了一种特殊的位数据类型(bit)。位数据存储在CPU内部的位寻址区中，可像操作其它变量一样对其操作，但是位变量不能进行指针操作

![image-20250104145833260](./images/image-20250104145833260.png)

| 类型 | 关键字        | 位数 | 数据范围 |
| ---- | ------------- | ---- | -------- |
| 整型 | int           | 16   |          |
|      | short         | 16   |          |
|      | long          | 32   |          |
|      | unsigned int  | 16   |          |
|      | u short int   | 16   |          |
|      | u long int    | 32   |          |
| 实型 | float         | 32   |          |
|      | double        | 64   |          |
|      | char          | 8    |          |
|      | unsigned char | 8    |          |

l特殊功能寄存器
Ø特殊功能寄存器用sfr 来定义，而sfr16 用来定义16 位的特殊功能寄存器如DPTR；
Ø可以通过名字或地址来引用特殊功能寄存器。 可位寻址的特殊功能寄存器（如SCON）的位变量定义用关键字sbit 。这些定义是用引入头文件（*.H）实现的；
ØKeil为目前大多数51内核的单片机配备了相应的头文件，这些头文件包含了该种单片机所有的特殊功能寄存器以及控制位的定义，通过包含这些头文件可以很容易的进行新的扩展。

```c
//SFR在头文件中的定义
sfr SCON=0x98; // 定义SCON
sbit SM0 =0x9F; // 定义SCON 的各位
sbit SM1 =0x9E;
sbit SM2 =0x9D;
sbit REN =0x9C;
sbit TB8 =0x9B;
sbit RB8 =0X9A;
sbit TI=0x99;
sbit RI=0x98;
```

### C51的存储模式

C51编译器完全支持MCS-51型单片机的存储结构。该编译器引入了存储模式关键字，通过将变量、常量定义成不同的存储模式(类型)的方法，将它们定位在不同的存储空间中。在C51中对变量进行定义的格式如下：
[存储种类] 数据类型 [存储器类型] 变量名表;
[存储种类]和[存储器类型]是可选项。变量的存储
种类有自动(auto)、外部(extern)、静态(static)和寄存器(register)共四种。如果定义变量时省略了存储种类，则该变量缺省为自动(auto)变量。

![image-20250104150100234](./images/image-20250104150100234.png)

> C51和C语言，多了变量类型和库函数 
>
> 存储结构:
>
> 1. data：直接寻址，128字节
> 2. bdata：
> 3. idata：间接访问呃 
> 4. pdata：片外数据存储区
> 5. xdata：movx@dptr
> 6. code：movx@dptr

1、data存储模式
l由于编译器会把声明为data的变量存放在单片机内部RAM的低128字节，并通过直接寻址的方式访问，因此对data区的寻址是最快的，所以应该把使用频率高的变量放在data区。但要注意的是声明为data类的存储区除了包含程序变量外，还包含了堆栈和寄存器组。使用时要加以注意。
ldata存储模式的声明如下：

```c
unsigned char data system_status=0;
unsigned int data unit_id[2];
data char input_string[16];
float data output_value;
mytype data new_var;
```

注意：如果某变量声明未指定类型，则编译器会将其放在当前存储模式的缺省数据区。

只要不超过内部data区的范围，系统变量和用户变量均可存放在其中。使用时要考虑到C51使用寄存器组传递函数的参数(因此data区至少被占用8字节)，此外还要留出足够的堆栈空间(大小和中断源数、函数调用嵌套层数相关，编译器会自动处理，用户基本不用考虑此问题。这一点也是高级语言比汇编更方便的原因之一)。

2、bdata存储模式
定义为bdata存储类型的变量，可以进行位寻址，可声明位变量。这对于一些需要单独操作字节中某些位的应用场合非常适用；
但是要注意，bdata存储区只能存储字符型及整型变量，编译器不允许在bdata存储区中定义float、double类型的变量。

3、idata存储模式
lidata存储区对应MCS-52系列单片机内部RAM的高128字节的存储空间，也可存放使用比较频繁的变量。这些变量使用MOV @Ri的寄存器间接寻址方式进行寻址。和外部存储器寻址比较，它的指令执行周期和代码长度都比较短。
例如：

```c
unsigned char idata system_status=0;
unsigned int idata unit_id[2];
idata char input_string[16];
idata float output_value;
```

4、pdata和xdata存储模式
pdata存储区对应外部RAM最低256字节的存储空间，通过MOVX @R0/@R1间址方式寻址。
xdata区则对应全部外部RAM的64K寻址空间，通过MOVX @DPTR方式寻址。
由于pdata区的地址为8位而xdata区为16位，因此p
data区的寻址比xdata区的寻址快。

```c
unsigned char xdata system_status=0;
unsigned int pdata unit_id[2];
xdata char input_string[16];
pdata float output_value;
```

外部RAM地址除了访问物理存储器的地址外，还包含I/O器件的译码选通地址。对外部器件寻址可通过指针或C51提供的宏来完成，可读性更好。

宏定义看上去像char或int类型的数组：

```c
inp_byte = XBYTE[0x8500];// 从XRAM地址8500H读一个字节
inp_word = XWORD[0x4000];// 从XRAM地址4000H读两个字节
XBYTE[0x7500]=out_val;// 写一个字节到XRAM的7500H
```

可对外部RAM的所有存储单元采用以上方法进行寻址。使用绝对地址访问的宏需要包含头文件`absacc.h`

5、code存储模式
MCS-51的代码区为只读存储器，不可重写。一般代码区中除了程序代码外，还可存放数据表。数据表在源程序中定义，在编译过程中初始化。

```c
unsigned int code unit_id = 1234;
unsigned char code Table[] = 
{0x00, 0x01, 0x02, 0x03, 0x04, 0x05};
```

### C51的指针

指针的本质是一个与地址相关的复合类型，它的值是数据存放的位置(地址)。C51提供一个3字节
的通用存储器指针，通用指针的第一个字节表明指针所指向的变量的存储空间，另外两个字节存储16位偏移量。对明确声明为data、idata和pdata类型的指针只需要8位偏移量。

Keil允许使用者规定指针指向的存储区。这种指针叫具体指针。使用具体指针的好处是节省了存储
空间，编译器不用根据指针类型选择存储空间、确定寻址方式，这样就使代码更加简短。

```c
char *str1;// 未指明存储空间，通用指针
char data *str2;// 指明存储空间，具体指针
```


由于具体指针操作比通用指针的操作快得多，因此在一般情况下，不推荐使用通用指针。

![image-20250104150303447](./images/image-20250104150303447.png)

### C51的中断服务程序

![image-20250104150318137](./images/image-20250104150318137.png)

编译器在生成中断服务程序时，会自动在入口处保护所有将在ISR中使用的寄存器、存储单元(压入堆栈)，并在退出ISR之前恢复现场。
可以通过using关键字指定某ISR使用的具体的寄存器组：

```c
void Int0Isr(void) interrupt 0 using 3
{
… …
}
```

此时在ISR入口处将不再产生将当前寄存器组压入堆栈的代码，这样有利于快速响应中断。但因为
在C中所有函数参数传递、指针引用等都要用到寄存器间接寻址的方式，因此，这种方法带来的副作用是：所有ISR中调用的函数、使用的变量都必须基于同一个寄存器组，否则将出错。

### 编程质量

1、采用短变量
一个提高代码效率的最基本的方式就是减小变量的字长，提高速度。例如，使用传统C编程时我们
都习惯于对循环控制变量使用int类型，如果循环次数在255次以下，完全可以采用unsigned char型
变量作为循环控制变量。编程者应该根据变量值可能的取值范围选择合适的变量类型(字长)。

2、尽量使用无符号类型变量
由于MCS-51并不支持符号运算，符号运算要通过库函数等方式实现，这会引起程序性能的下降。编程者应根据应用的具体情况，尽量不使用带符号的变量。

3、避免使用浮点数及浮点数指针
在8位字长的单片机系统上使用32位浮点数会引起程序体积的增大和程序效率的极大下降。在实际
使用中，可以通过提高数值数量级和使用整型运算来避免使用浮点数/指针运算。

4、尽可能多使用位变量
对于程序中使用的只有两种取值的标志位，应尽可能使用位变量而不是char。这将提高操作效率，节省内存。

5、用局部变量代替全局变量
把变量定义成局部变量比全局变量更有效率。编译器可通过覆盖处理使内存的使用效率更高，同时还可以避免多个程序调用公共变量时引起的同步问题。

尽量将变量分配在内部存储区
这样可以提高程序运行的速度、减小代码占用的空间。在保证足够的堆栈空间的情况下，建议按下列顺序定义变量：
data  idata  pdata  xdata
对应寻址方式：
Ødata:直接寻址。如 MOV A,30H
Øidata:R0~7间接寻址。如 MOV A,@R7
Øpdata:外部RAM R0,1间址。如 MOVX A,@R0
Øxdata:外部RAM DPTR间址。MOVX A,@DPTR

7、使用特定指针
在定义指针时应明确指定其所指向的存储类型，如data、xdata等，这样编译器会根据指针的存储
空间自动生成合适的指针代码，这样速度更快，代码更紧凑。
通用指针需占用3字节代码空间，而xdata指针以及code指针为2字节，data、idata、pdata指针只有1字节，且具体指针因为存储模式以确定，其操作速度比通用指针快。

8、使用内联函数
l对于一些简单的操作如变量循环位移，编译器提供了一些内联函数供用户调用。多数内联函数直接对应着汇编指令，因此可较大地提高程序的性能。少数的比较复杂的内联函数也是和ANSI兼容的;
l所有的内联函数都是可重入函数，可以在任何地方安全的调用。

例如，和单字节循环位移指令RL A和RR A相对应的内联函数是_crol_(循环左移)和_cror_(循环右移)。对于int类型，对应的内联函数为_irol_,_iror_，对于long类型的内联函数为_lrol_, _lror_;
l在C51中也提供了和汇编中JBC指令对应的内联函数：_testbit_，如果参数位置位，函数返回1，同时清除该位，否则返回0。这在检查标志位时十分有用，且使C51的代码更具有可读性。

9、必要时使用宏来替代函数
l对于小段频繁使用的代码，例如使能某些电路或从锁存器中读取数据等，可把代码定义在宏中，通过宏来替代函数，使得程序有更好的可读性和执行效率(不用频繁调用函数)。编译器在遇到宏时，用事先定义的代码去替代宏。当需要改变宏时，只要修改该宏的定义即可。

例如，参考以下代码：

```c
#define led_on() {\
led_state=LED_ON; \
XBYTE[LED_CNTRL] = 0x01;}
#define led_off() {\
led_state=LED_OFF; \
XBYTE[LED_CNTRL] = 0x00;}
```


l宏代换使得程序有更好的可读性和可维护性。

10、选择合适的存储方式

Keil C51提供了三种变量存储模式：
ØSmall(小模式): 所有变量均存储在内部RAM中；
ØCompact(紧凑模式)：变量缺省分配在片外低256字节的RAM空间(pdata)中，通过MOVX @R0/@R1的方式间接寻址；
ØLarge(大模式)：所有变量的缺省存储空间是xdata区；
只要硬件允许，Keil支持在同一程序中声明采用不同存储方式的变量，这使得C51的代码非常的灵活、高效。