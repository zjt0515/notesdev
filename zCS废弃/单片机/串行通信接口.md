## hello world

> 在传统的C语言程序设计中，标准输出对应的设备是屏幕，通过函数printf()将字符串输出到显示屏上；标准输入对应的是键盘，通过函数scanf()从键盘读取用户输入的字符；
>
> 单片机本身硬件资源有限，并没有屏幕和键盘，所以C51设计的标准输出和标准输入所对应的设备都是串行口。即在用C51编写的单片机程序中，printf()函数输出的字符串将送单片机的串行口发送，而scanf()函数则从单片机的串行口读取输入的数据。

 在使用单片机的串行口进行通信前，首先要对其进行初始化，对通信帧格式及波特率进行设定，保证通信双方通信帧格式及波特率一致；
l 在硬件电路上，单片机系统之间短距离的通信可以将引脚直接用导线相连；
l 如果通信距离较远或者单片机需要和PC机进行通信，则必须进行TTL/CMOS电平与RS-232C电平的变换方能正常通信；
l 关于串行口波特率设置、电平变换等内容在第二章中已有详细讲解，请自行参阅。

```c
// hello world
#include <reg51.h>// 对单片机的端口、寄存器等内部资源进行定义的头文件
#include <stdio.h>// 程序中如果使用输入/输出函数，必须包含此头文件
// 使用define定义系统中的常数，既清晰明了，又方便修改
#defineOSC11059200
#defineBAUD9600
void main(void)
{
  TMOD = 0x20;// T1选择模式2，用于波特率发生器
  SCON = 0x50;// 串口方式1（N81），REN=1，允许接收
  PCON |= 0x80;// SMOD=1，波特率倍增
  TL1= 256 - (OSC/12/16/BAUD);
  TH1= 256 - (OSC/12/16/BAUD);// 计算并设置波特率常数（串行口硬件以设定
  // 波特率的16倍速率扫描串行通信线路）
  TR1= 1;// 启动定时器，波特率发生器开始工作
  TI= 1;// 使用printf函数的要求
  printf("\r\nHello, world!\r\n");// 输出Hello, world!，前后均换行
  while(1);// 执行完毕，在此处循环，以免程序“跑飞”
}
```

printf函数可通过串行口输出各种格式化的字符或字符串，而
每个字符的输出则是调用putchar函数实现的：

```c
char putchar (char c)
{
  if (c == '\n')// 如果输出的是换行符
  {
  while (!TI);// 如TI不为1，等待其变为1。即等待上一字符发完
  TI = 0;
  SBUF = 0x0d;// 自动增加一个回车符
  }
  while (!TI);// 每次都等待前一个字节发完再发下一字节
  TI = 0;// 清除TI标志
  return (SBUF = c);// 发送待发字节并返回
}
```

 scanf函数可通过串行口输入各种格式化的字符或字符串，而
每个字符的输入则是调用getkey函数实现的：

```c
#include <reg51.h>
char _getkey ()
{
  char c;
  while (!RI);// 等待串行口接收完一个字节的数据
  c = SBUF;// 将串行口接收的数据存入临时变量
  RI = 0;// 清RI标志
  return (c);// 返回接收到的数据字节
}
```

> 单片机IO重定向
>
> 1. 在实际应用中，程序员可通过更改putchar函数，例如将putchar更改为向液晶显示器模块(LCM)输出，即可实现printf函数在不同外设上的格式化输出；
> 2. 在实际应用中，程序员可通过更改 _getkey函数，例如将 _getkey更改为从扩展的行列式键盘读取数据，即可实现scanf函数在不同外设上的格式化输入；
> 3. 实际编程时，只要将putchar或 _getkey函数加入到工程文件中，编译链接即可取代标准库函数中相应的函数。

## 串行口查询方式通信

> 7.2.1 设计思路分析
> l 特殊功能寄存器SCON中的TI位和RI位分别表示当前串行口数据收发的状态；
> l TI为发送结束标志位，在一字节数据发送完毕时置1；
> l RI为接收完成标志位，在一字节数据接收完成时置1；
> l TI和RI中任何一个为1，都可向CPU申请串行口中断。即使单片机设置为不响应任何中断，TI和RI仍会根据串行帧的收发情况置位或复位；
> l 通过TI和RI可实现查询方式的串行通信。
> 
> 单片机发送数据时，可采用两种查询方式：
> Ø 方式一：发送数据前先查TI是否为1，TI=1表示上一个数据已经发完，则先置TI=0，再发送数据，否则等待TI=1。此方式下发送数据指令执行完毕后即可返回。注意此方式要求在初始化串口时先置TI=1；
>Ø 方式二：串口初始化时置TI=0，此后向串行口发送数据时，将待发送数据写入SBUF后，必须等待TI为1，并将TI清零后再返回。
> l 单片机接收数据时，只要查询到RI为1，就表示有一个有效的数据字节已被接收到SBUF中。
> l 单片机应及时从SBUF中读取本次接收到的数据，以免该数据被下一个接收的数据覆盖。
> 
> 当单片机需要同时进行数据的接收和发送时，要采用轮询的方式进行，在一个大循环中分别查询各标志，使用if或switch语句而不是while语句来判断标志是否满足条件，以避免某一标志始终不出现而导致系统死锁。

### 程序实例

使用C51设计单片机串行口控制程序，设单片机的晶振频率为11.0592MHz，串行口工作在9600bps、8位数据位、1位停止位、无校验模式。单片机采用查询方式控制数据的收发流程，将串行口接收到的除回车/换行之外的数据加1后送回。 
Ø 根据程序要求，单片机应被动等待对方先发数据，再根据收到的数据判断如何回送，因此单片机初始化完成后首先应等待接收数据，结合晶振频率及要求的单片机串行口工作方式，设计程序如下：![image-20250104140414721](./images/image-20250104140414721.png)

![image-20250104140422106](./images/image-20250104140422106.png)

## 串行口中断方式通信

### 设计思路

> 7.3.1 设计思路分析
>
> 1. 当CPU开放串行口中断时，RI或TI中任一个为1（即收到或发完一个字节）时都会向CPU申请中断，在中断服务程序中进行数据处理。在没有中断发生的时候，CPU可执行其它任务；
> 2. 在实际程序设计中，根据具体情况，通过中断服务程序可选择处理某一个或全部中断事件；
> 3. 中断服务程序应遵循“先保存后处理”的原则，尽量减少中断服务程序（ISR）的执行时间；
> 4. 使用中断方式管理串行数据的收发，可极大提高代码的执行效率。
>
> 1、只处理串行口接收数据中断
>
> 1. 由于串行通信时发送数据是在程序的控制下主动进行的，程序只要在发送数据前查询TI位，确保前一个串行帧发送完毕前不发送下一帧即可，因此串行数据的发送可以不使用中断；
> 2. 而串行数据的接收则是随机的，何时接收数据完全取决于对方，故应该采用中断方式进行接收；
> 3. 在这种情况下，每个数据字节发送完成时，硬件仍会自动置TI=1，CPU也响应该中断。但是只要在中断服务程序中不清除TI，TI将保持不变，供主程序查询。
>
> ![image-20250104140450076](./images/image-20250104140450076.png)
>
> 2、处理串行口接收数据和发送数据中断
>
> 1. 为了进一步提高串行口数据收发的效率，串行口发送数据也可以采用中断驱动的方式；
> 2. 程序首先将待发送的数据送入数据发送缓冲区；
> 3. 在第一个数据发送前强制置TI=1引发串行口发送中断；
> 4. CPU响应中断，进入中断服务程序进行数据发送处理，数据发完后将引发中断，继续后续数据的发送；
> 5. 中断方式数据接收处理过程和前述的方法相同。
>
> ![image-20250104140537113](./images/image-20250104140537113.png)

3、数据的缓冲

1. 数据缓冲的目的是为了加快CPU对数据收发的响应速度和系统事件处理的效率；
2. 数据缓冲通常采用“先存储，后处理”的方式，即在ISR中只进行数据的收发，数据的处理则由其他模块完成；
3. 在存储空间比较紧张的单片机系统中，一般通过内存需求较小的环形队列来实现数据的缓冲

![image-20250104140600152](./images/image-20250104140600152.png)

![image-20250104140605923](./images/image-20250104140605923.png)

![image-20250104140612192](./images/image-20250104140612192.png)

![image-20250104140617458](./images/image-20250104140617458.png)

![image-20250104140622265](./images/image-20250104140622265.png)

![image-20250104140626994](./images/image-20250104140626994.png)

![image-20250104140632469](./images/image-20250104140632469.png)

缓冲区存储字节数的计算
Ø 缓冲区中的数据是“先存储，后读取”，缓冲区中存储字节数的计算
方法为：
$$
bytes = WPtr - RPtr;// 写指针-读指针\\
if(bytes < 0) bytes += BUFSIZE;\\ // 写指针回卷将计算出负值
// 此时应加上缓冲区长度
$$

l 根据前面的分析，如果计算结果表明环形队列中已经存储了BUFSIZE-1字节的数据时，表示队列区已满，此后不应再向队列中存储数据（直到队列中的一个或多个数据被读出为止）。

如果缓冲区大于256字节，WPtr和RPtr必须采用整型数，8位单片机处理时将分多条指令完成；
l 此时有可能出现这样的情况：主程序根据读写指针值计算缓冲区存储字节数时被串行口中断打断，而串行口中断服务程序读写缓冲区数据时，又更改了缓冲区的读写指针；
l 当中断服务程序执行完毕返回主程序后，主程序继续计算出的缓冲区存储字节数就有可能出错；
l 为了避免这种情况的发生，当计算环形队列存储字节数时，要暂时禁止串行口中断，计算完毕再开放串口中断。暂时禁止串行口中断并不会影响串行口的数据收发；
l 这是因为当初始化串行口时，串行数据的每一位都要进行至少16次扫描，假设波特率设置到当前晶振下的最高值，即定时器T1初值设置为255，每个机器周期溢出一次，那么收发一个串行帧(10bit)，则至少需要160个机器周期；
l 而整型数的加减法仅需不超过二十个机器周期即可计算完毕，因此不会因暂时禁止串口中断而影响串行数据收发。

### 程序实例

使用C51设计单片机串行口控制程序，设单片机的晶振频率为11.0592MHz，串行口工作在9600bps、8位数据位、1位停止位、无校验模式。单片机采用全中断方式控制数据的收发流程，使用环形缓冲区存储串行口接收到的数据，并将收到的除回车/换行之外的数据加1后送回

根据题目要求，单片机处理串行口的接收中断和发送中断，存储接收数据的环形缓冲区的大小由BUFSIZE定义，编写程序如下：

![image-20250104140751441](./images/image-20250104140751441.png)

![image-20250104140757927](./images/image-20250104140757927.png)

![image-20250104140803015](./images/image-20250104140803015.png)

![image-20250104140808689](./images/image-20250104140808689.png)

## 通过16C550扩展串行通信接口

> 随着嵌入式应用越来越复杂，很多通信类项目都有多串口应用的需求，但标准的MCS-51只提供了一个串行口；
>
> 1. 虽然现在有部分双串口单片机，如台湾华邦(Winbond) 的W77E58、Cygnal的C8051F系列单片机中的部分型号等，但昂贵的价格影响了它们的普及。而且在需要使用多于两个串行口
>     的应用场合，双串口单片机也无能为力；
> 2. 16C550为专门的串行口扩展芯片，有多种规格，在一块芯片上可提供1路(16C550)、2路(16C552)或4路(16C554)串行口的扩展，是目前串行口扩展芯片领域事实上的工业标准。很多嵌入式CPU内部集成的串行口都兼容16C550。

### 16C550

> 16C550为TI公司设计生产的串行通信接口芯片，应用非常广
> 泛，目前已成为事实上的工业标准；
> 16C550的主要特性
>
> 1. 5V和3.3V的工作电压，工业级温度范围； 
> 2. 最高可支持1Mbps的串行通信速率；
> 3. 支持完整的硬件流控及Modem控制；
> 4. 可编程设置多种通信帧格式：
>     • 可设置为5～8位数据位，1、1.5、2位停止位；
>     • 可设置奇校验、偶校验、Mark、Space、无校验等校验方式；
>     • 具有伪起始位检测功能等等…
> 5. 具有完整的Modem控制信号等等…

![image-20250104140928409](./images/image-20250104140928409.png)

![image-20250104140935233](./images/image-20250104140935233.png)

![image-20250104140943888](./images/image-20250104140943888.png)

![image-20250104140951320](./images/image-20250104140951320.png)

![image-20250104140958445](./images/image-20250104140958445.png)

![image-20250104141006849](./images/image-20250104141006849.png)

![image-20250104141040477](./images/image-20250104141040477.png)

![image-20250104141052307](./images/image-20250104141052307.png)

![image-20250104141058744](./images/image-20250104141058744.png)

![image-20250104141104215](./images/image-20250104141104215.png)

![image-20250104141113437](./images/image-20250104141113437.png)

![image-20250104141123494](./images/image-20250104141123494.png)

![image-20250104141131026](./images/image-20250104141131026.png)

![image-20250104141137431](./images/image-20250104141137431.png)

![image-20250104141143443](./images/image-20250104141143443.png)

![image-20250104141149051](./images/image-20250104141149051.png)

![image-20250104141155085](./images/image-20250104141155085.png)

![image-20250104141200366](./images/image-20250104141200366.png)

### 程序设计实例

![image-20250104141244254](./images/image-20250104141244254.png)

![image-20250104141230732](./images/image-20250104141230732.png)

![image-20250104141251094](./images/image-20250104141251094.png)

![image-20250104141255970](./images/image-20250104141255970.png)

## 通过RS-485总线实现单片机的多机通信

> RS-485总线通信方式的特点
> Ø 速度较高 ━━ 250Kbps~1Mbps；
> Ø 通信距离远 ━━ 无中继通信距离达4000英尺/1200米；
> Ø 信号电平兼容 ━━ 线路采用差分方式驱动；
> Ø 支持多点通信━━ 同一总线下可挂接多达128个节点；
> l 目前常用的RS-485总线驱动芯片
> Ø MAX48x/148x系列、75176、SP48x等；
> Ø 通信方式有半双工和全双工；
> Ø 芯片等级分为商业级（0~70℃）、工业级（-40~85 ℃）和汽车/军事
> 级（-55~125 ℃）;
> Ø 同一总线下最多可挂接32~128个节点。

![image-20250104141324041](./images/image-20250104141324041.png)

### 主从多机通信原理

1、多机通信控制位

1. 当串行口工作在方式2或3（多机通信模式）接收数据时，SCON中的SM2为多机通信控制位：
    1. 多机通信模式下，单片机串行口发送和接收数据均增加1位附加位，分别记为TB8和RB8；
    2. 单片机串行口发送一字节的数据时，TB8将紧接在该字节后发出；
    3. TB8和RB8位于SCON中，可位寻址。
2. 当串行口工作在方式2或3（多机通信模式）接收数据时，SCON中的SM2为多机通信控制位：
    1. SM2=1时，单片机串行口接收一个字节后，只有当紧接该字节的第9位数据RB8也为1时，该字节才会被装入SBUF，并置RI为1。否则单片机认为该数据无效，不置位RI，CPU也不会做任何处理；
    2. SM2=0时，单片机串行口接收一个字节后，不管紧随其后的
        RB8是0还是1，均会将该字节装入SBUF，并置RI为1；
    3. 利用单片机的上述特性，可实现主从式半双工多机通信。

2、主从式半双工多机通信系统的构成及原理 

1. 主从式半双工多机通信系统的构成
    1. 采用RS-485总线；
    2. 采用一主机+多从机的结构；
    3. 单片机使用串口方式2或3进行多机通信；
    4. 主机采用轮询的方式访问各从机；
    5. 各从机之间的数据交换只能通过主机进行转发；
    6. 或者各节点轮流成为主机（需要协议支持）；
    7. 因为任何时候通信都只能是单向的（主机->从机或从机->主机），所以构成的是半双工的通信系统。
2. 多机通信的实现
    1. 使所有从机SM2=1，等待主机发送地址；
    2. 主机置TB8=1表示发送的是地址，并发送地址字节；
    3. 所有从机都可收到此字节，各自比较地址码是否和主机发来的数据相符，地址码符合的从机置SM2=0；
    4. 主机给被寻址的从机发送数据，发送数据期间置TB8为0，此时只有SM2=0的从机可收到该数据，其它所有的SM2=1的从机不会接收TB8=0的数据；
    5. 主机和被寻址从机间完成数据通信，主机置TB8=1、从机置SM2=1，准备开始下一轮循环。

### 主从多机通信实例

![image-20250104141422818](./images/image-20250104141422818.png)

![image-20250104141426949](./images/image-20250104141426949.png)

![image-20250104141431443](./images/image-20250104141431443.png)