填空、单选、判断、简答、解答、设计

## 1、翻译程序的三个类型(汇编|解释|编译)

1. **汇编**程序：汇编语言源程序à机器语言目标程序 
2. **解释**程序：边解释边执行，保存中间结果 
3. **编译**程序：高级语言源程序à目标语言（机器语言/汇编语言）程序



## 2、自编译、交叉编译的概念 | 对T型图的理解

自编译：一种**高级语言与之对应的编译程序**也能**直接用该语言本身**写出来。
交叉编译：一个 A 机器上编译程序能产生 B 机器的目标代码。

### 自编译的T型图

![image-20240629011108923](./images/image-20240629011108923.png)

### 交叉编译的T型图

A机器上通过编译程序最终产生B机器目标代码

![image-20240618154355621](./images/image-20240618154355621.png)





### T型图

T型图描述了一个编译器：用书写语言描述的，将源语言翻译成目标语言的编译程序
串联T形图：相遇部分必须相等才能串联

![image-20240618132329954](./images/image-20240618132329954.png)

![image-20240618132340364](./images/image-20240618132340364.png)

A机器：给你一个A机器，就自带一个A机器语言，可以将A机器语言作为书写语言
A机器上存在一个C语言编译器：![image-20240618161153575](./images/image-20240618161153575.png)

**A机器上有了C语言编译器之后，C语言就可以作为书写语言**



本机编译：A机器上有X语言编译器，构造A机器上另一种语言的编译器
第三个T形图：是前2个的总结，源语言是第一个T的源语言，目标语言是第一个T的目标语言

![image-20240618154345232](./images/image-20240618154345232.png)



## 3、系统程序设计语言的概念(编译程序、系统软件)

系统程序设计语言：能够编写**编译程序**或其他**系统软件**的高级语言。

## 4、知道各种推导和归约的长度

直接推导 ⇒ ：仅使用一次规则，长度为 1 
推导 ⇒+ ：至少使用一次规则，长度≥1 
广义推导 ⇒∗ ：经过 0 步或若干步的推导，长度≥0

## 5、知道句型、句子、语言的概念+

范围：句型>语言>句子

句型：如果符号串 x 由识别符 Z 推导（长度≥1）而得，称 x 为 G 的一个句型。 
(推导而来的都是句型？)

句子：如果 x 仅由终结符组成，则称句型 x 为该文法的一个句子。 
(只包含终结符的句型)

语言：由某文法所产生的一切句子的集合称为由该文法所确定的语言。
(句子的集合)

![image-20240618153847329](./images/image-20240618153847329.png)



## 6、给定文法会写其产生的语言(文法->正规表达式)

用正规表达式和文字描述

![image-20240618154015610](./images/image-20240618154015610.png)

![image-20240618160121024](./images/image-20240618160121024.png)

![image-20240618162452665](./images/image-20240618162452665.png)

## 7、能判断产生某语言的文法是哪一个



## 8、递归文法的作用

递归规则：在规则左部和右部具有相同的非终结符规则（P78 改写法消除左递归） 
递归文法：至少含有一个递归非终结符的文法 
判断：如果一个语言是无穷的，则描述该语言的文法必定是递归的。

## 9、画句型的语法树，找出短语、简单短语、句柄(子树驱动)

短语：Z⇒∗xUy, U∈VN 且 U⇒+u, u∈V+ 
简单短语：Z⇒∗xUy, U∈VN 且 U⇒u 
句柄：句型最左边的简单短语（语法树最下层最左侧）

- 短语：每棵子树的叶子节点构成短语，子树包括最大的树
- 简单短语：最多2层的树，不能再包含子树了
- 句柄：最左边的简单短语

![image-20240618132848516](./images/image-20240618132848516.png)

![image-20240618155441638](./images/image-20240618155441638.png)

## 10、证明文法的二义性(同一个句子有2棵不同语法树)

 文法的二义性：一个文法中的某句型对应两棵不同的语法树（一个文法中的某句子
对应两个不同的最左推导或最右推导）

![image-20240618154631668](./images/image-20240618154631668.png)

## 11、判断乔姆斯基文法的类型(左部非终结符存在？单个？，左右部长度、右部形式)

逐步增加对产生式的限制条件

0. 短语结构文法：左边都存在非终结符
1. 上下文有关文法：所有产生式右部长度都 >= 左部长度
2. 上下文无关文法：产生式左边都是单个非终结符
3. 正规文法：产生式右部只有3种形式：单个终结符或者空串、单个终结符+一个非终结符（按照顺序具体分为左线性或者右线性，只能满足一个）ε | A | Aa(aA)
    1. 正规文法分为：左/右线性文法，只能满足一个

> 解题步骤：(不用每个产生式都依次应用一遍4条规则)
>
> 1. 先对每个产生式应用2型文法规则（即判断：左部都是单个非终结符），把2、3形先筛选出来再具体判断
> 2. 再对剩余的文法用1形规则筛选为1形文法（即判断：右部都大于等于左部，不满足是0形文法



## 12、写文法的压缩过文法(删去不可到达和不可终止的产生式)

文法中不含有形如 A::=A 的规则 
每一个非终结符必须在某句型中出现（不可到达） 
(由开始符号根本到不了的非终结符)

非终结符 A 必须推出终结符串 t（不可终止）

![image-20240618153439984](./images/image-20240618153439984.png)

注：A::=Ae|e 这是对的，因为满足终止

## 13、画左/右线性文法的状态转换图及其正规式

左线性：

![image-20240618162005280](./images/image-20240618162005280.png)

右线性：

![image-20240618162128445](./images/image-20240618162128445.png)

## 左右线性文法转换



## 14、能根据转换系统写出正规式，并对该转换系统确定化

## ~~14、能根据某正规式构建转换系统能根据转换系统写出正规式，并对该转换系统确定化、重命名并判断能否化简~~





## 15、会判断状态转换图能否化简



## 16、会判断两个正规式是否等价



## 17、会利用两种方法消除文法的左递归

### 直接左递归

![image-20240618163227593](./images/image-20240618163227593.png)

### 间接左递归

![image-20240619010119246](./images/image-20240619010119246.png)



## 18、会求First集和Follow集合，且能由此构造LL(1)分析表，并判断文法是否为LL(1)文法

### 求FIRST集



### 求FOLLOW集



### 求FIRST集、求FOLLOW集、构造LL1分析表

求FIRST集：对每条独立的产生式求FIRST集
FOLLOW集：对上面FIRST集中存在ε的集合对应的左部求FOLLOW集

### 用分析表判断符号串是否为文法的句子(步骤、#分析栈、余留输入串#、产生式)

画表格，最后2个栈都是#就是成功

1. 步骤：从1写到最后
2. 分析栈：# + 开始的非终结符
3. 余留输入串：待判断的串+#
4. 所用产生式：LL1表中对应的产生式

![image-20240629012453004](./images/image-20240629012453004.png)

分析步骤：

- 第一行初始化完后，每次就看分析栈和余留输入栈的栈顶元素，找LL1分析表中对应位置，用产生式右部**倒序进栈**
- 如果2个栈顶元素相同，那么可以约掉直接进入下一行
- 直到最后两个栈顶元素都是#，所用产生式是成功

## ~~19、会判断LR项目的类型~~





## 20、知道SLR(1)分析法的具体做法(状态栈0、#符号栈、输入串#、动作)



### LR0、LR1、SLR

不是LR0文法：一个状态中存在移进项目和归约项目，就是移进归约冲突

SLR解决移进归约冲突：

1. 构造集合1：所有移进项目的符号是一个集合，每个归约项目对应的左部的FOLLOW集
2. 只要集合两两不相交，就是SLR

## 21、会构造LR(1)文法识别活前缀的DFA并造表，同时会判断其是否可以压缩为LALR(1)并说明理由(同心项合并)



### 构造LR1活前缀DFA

向前搜索符(需要求first集)：

S->AB，AB都挪到左边后，相当于S挪到左边，未来必然面对的符号

搜索符号照抄

### LR1分析表

区别：

对于归约项目，$action(k,搜索符号)=rj$​

![image-20240629081341804](./images/image-20240629081341804.png)

### 判断LALR1文法

找同心项：，前面的项目都一样，然后合并

![image-20240629081640635](./images/image-20240629081640635.png)

归约归约冲突，不是LALR1：对于同一个搜索符号，有2个待约项目

![image-20240629081822552](./images/image-20240629081822552.png)

1. 





## 22、能实现算数运算的后缀表达式和中缀表达式间的转换

![image-20240618163757606](./images/image-20240618163757606.png)

![image-20240618163808078](./images/image-20240618163808078.png)

## 23、将条件语句转成POST数组形式和四元式形式

P107，不考表左边，考表右边的结果（结果就是四元式

- jnz：非0跳转
- 跳转写未来回填0，不跳转写假出口0



$$
100(j<,A,X,102)\\
100不满足：101(j,-,-,109)\\
100满足：102(j>,B,0,104)\\
103(j,-,-,109)\\
104(j>,c,0,106)\\
105(j,-,-,109)\\
算数运算：106(+,c,d,T_1)\\
赋值：107(:=,T_1,-,c)\\
无条件跳转：108(j,-,-,104)\\
109
$$





## 24、设计题：能设计出产生某语言的状态转换图或 DFA

给你某种语言的描述，请你设计出能够产生这个语言的状态转换图或者设计出其DFA（两者任选）。