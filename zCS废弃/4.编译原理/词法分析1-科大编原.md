## 第一讲：RE转换成NFA：Thompson算法 (3.1)

递归结构算法，从小的re递归构造大的re

![image-20240607085158213](./images/image-20240607085158213.png)![image-20240607085506133](./images/image-20240607085506133.png)



示例

![image-20240607085838897](./images/image-20240607085838897.png)

## 第二讲：NFA转换成DFA：子集构造算法 (3.2)

状态转移不确定到确定

构造子集

1. 求转换过程`delta(q,c)`，q集合里的节点能经过字符c走到的节点集合
    1. 注：这里对c字符要取所有可能，就是要看每一个nfa中q集合节点元素
2. 对该集合并上他的空字闭包，即看集合内每个元素能经过空字走到哪些节点

![image-20240607104706084](./images/image-20240607104706084.png)

### 子集构造算法伪代码

![image-20240607105901490](./images/image-20240607105901490.png)

示例

![image-20240607111144604](./images/image-20240607111144604.png)

算法分析

![image-20240607111450908](./images/image-20240607111450908.png)

![image-20240607130104165](./images/image-20240607130104165.png)

## 第三讲：DFA的最小化：Hopcroft算法 (3.3)

![image-20240607143809106](./images/image-20240607143809106.png)

![image-20240607195707194](./images/image-20240607195707194.png)

示例

![image-20240607195903454](./images/image-20240607195903454.png)

![image-20240607201044492](./images/image-20240607201044492.png)



## 第四讲：从DFA生成分析算法 (3.4)