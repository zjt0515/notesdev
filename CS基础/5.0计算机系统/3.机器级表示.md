##  3.1.程序的机器级表示

产生汇编文件`gcc -Og -S xx.c`
产生机器代码文件`gcc -Og -c xx.c`
反汇编`objdump -d xx.o`

![image-20240506134819011](images/image-20240506134819011.png) 

![image-20240701221114545](./images/image-20240701221114545.png)



### x86-64寄存器

![image-20240506134905099](images/image-20240506134905099.png)

Caller-saved/Callee-saved 寄存器

![image-20240506135154478](images/image-20240506135154478.png)



### 汇编指令操作数大小后缀![image-20240506135457321](images/image-20240506135457321.png)

## 3.2.寄存器与数据传送指令

### C数据大小

| 有符号 | 无符号         | 32位 | 64位 |
| ------ | -------------- | ---- | ---- |
| char   | unsigned char  | 1    | 1    |
| short  | unsigned short | 2    | 2    |
| int    | unsigned       | 4    | 4    |
| long   | unsigned       | 4    | 8    |
| char * |                | 4    | 8    |
| float  |                | 4    | 4    |
| double |                | 8    | 8    |
|        |                |      |      |
|        |                |      |      |

### 寄存器大小

![image-20240506140121522](images/image-20240506140121522.png)

| 寄存器 | 作用                     | 描述         |
| ------ | ------------------------ | ------------ |
| rax    | 函数返回值               |              |
| rdi    | 保存函数传递的第一个参数 |              |
| rsi    | 保存函数传递的第二个参数 |              |
| rdx    | 第3个参数                |              |
| rcx    | 第4个参数                |              |
| r8     | 第5个参数                |              |
| r9     | 第6个参数                |              |
| rsp    | 指向栈顶                 | 栈顶指针     |
| rip    | 指向下一条执行指令的地址 | 程序计数器PC |

操作数

- 立即数$xx
- 寄存器r
- 内存引用`Imm(rb,ri,s) = Imm + rb + ri*s`
  - 不带$的立即数或者带括号的寄存器等都是内存引用

![image-20240506140830307](images/image-20240506140830307.png)



![image-20240506140531130](images/image-20240506140531130.png)





![image-20240506141031872](images/image-20240506141031872.png)

> [!WARNING]
>
> x86-64限制源操作数和目的操作数不能都是内存地址(内存到内存很慢)
>
> 解决办法：两条mov间接存
> `mov mem, reg`
> `move reg, mem`



### 指令的存放

多字节操作数连续存放，顺序依据小端法规则，即 : 低位字节存放在低地址单元，高位字节存放在相邻的高地址单元。

```
40110f:bb 78 56 34 12       mov    $0x12345678,%ebx
40110a:b8 78 56 34 12       mov    $0x12345678,%eax
```

intel：int x存放在0xFFFC000，x=0x12345678，则0xFFFC001存放了0x56
每一位地址存放一个2位16进制数

### 寻址方式

寻址方式：操作数位置的不同表示方法

![image-20240701212840885](./images/image-20240701212840885.png)

## 3.4.数据传送指令和栈

![image-20240506142741321](images/image-20240506142741321.png)

注意rdi保存了xp（地址值）
*xp=y，需要取xp地址对应的数字用y赋值，取地址就是取rdi的值对应的内存地址

程序栈：本质上是内存的一个区域

![image-20240506142959414](images/image-20240506142959414.png)



![image-20240506143220322](images/image-20240506143220322.png)



![image-20240506143351581](images/image-20240506143351581.png)

![image-20240506143500188](images/image-20240506143500188.png)







// todo: 不同文件类型的markdownTheme





### 操作数指示符

- 立即数：$0x8
- 寄存器：%rax
- 内存引用：(%rdi)
    - $r_b$：基址寄存器
    - $r_i$：变址寄存器
    - s：比例因子（1、2、4、8，具体取决于数组的类型char1 int4 double8）

|  类型  |           格式            |           数值            |     名称     |
| :----: | :-----------------------: | :-----------------------: | :----------: |
| 立即数 |           $Imm            |            Imm            | 立即数寻找之 |
| 寄存器 |           $r_a$           |                           |              |
| 存储器 |            Imm            |                           |   绝对寻址   |
| 存储器 | $(r_a)$(带了括号的寄存器) |                           |   间接寻址   |
| 存储器 |       $(r_b,r_i,s)$       | $M[Imm+R[r_b]+R[r_i]*s] $ |              |

> Imm如果没有0x，就是10进制，转换到地址要转成16进制

### 数据传送指令mov

| MOV S D | D = S | 传送          |
| ------- | ----- | ------------- |
| moveb   |       | 字节          |
| movw    |       | 字（2字节）   |
| movl    |       | 双字（4字节） |
| movq    |       | 四（8字节）   |
| movabsq |       | 绝对的四字    |

源操作数S：立即数、寄存器或内存引用
目的操作数D：寄存器或内存地址(不能是立即数)
指令必须和操作数 位数保持一致

> [!caution]
>
> x86-64：mov指令的S和D不能都是内存地址
> 需要2条mov指令，通过寄存器间接移动

> 当movq指令的S是立即数，只能是32位补码表示，符号位拓展，64位可以用movabsq
>
> x86-64：当movl的目的操作数是寄存器，会把寄存器的高4字节设置为0 

### 零拓展和符号位拓展

当源操作数的位数小于目的操作数，需要对目的操作数剩余字节进行零拓展/符号位拓展

 movz

| MOVZsr S R | S -> R         |      |
| ---------- | -------------- | ---- |
| movzbw     | 1字节 -> 2字节 |      |
| movezbl    | 1 -> 4         |      |
| movezwl    | 2 -> 4         |      |
| movezbq    | 1 -> 8         |      |
| movezwq    | 2 -> 8         |      |
| movl       | 4 -> 8         |      |

movs

| MOVSsr S R | S -> R         |                           |
| ---------- | -------------- | ------------------------- |
| movsbw     | 1字节 -> 2字节 |                           |
| movsbl     | 1 -> 4         |                           |
| movswl     | 2 -> 4         |                           |
| movsbq     | 1 -> 8         |                           |
| movswq     | 2 -> 8         |                           |
| movslq     | 4 -> 8         |                           |
| cltq       |                | 相当于`moveslq %eax %rax` |

### 栈

（栈底）高地址->低地址（栈顶）  <-栈顶指针rsp

`pushq %rax`

等效2步指令：

`subq $8, %rsp`
`movq %rax, (%rsp)`

`popq %rax`

`movq (%rsp), %rbx`
`addq $8, %rsp`

函数局部变量存入栈，不需要字节对齐
函数参数存入栈，需要8个字节对齐

## 3.5.算术和逻辑操作

### 加载有效地址

> x86 64上地址长度都是64位

 将S代表的地址传给D`leaq S, D`

leaq经常用于普通的算术操作，与有效地址计算无关

**用leaq实现算数运算**

```
leaq 7(%rdx,%rdx,4), %rax # %rax=5*%rdx+7
```



![image-20240506143956241](images/image-20240506143956241.png)

### 一元运算指令

一元操作
操作数既可以是寄存器也可以是内存地址

| 指令  | 效果      | 描述 |
| ----- | --------- | ---- |
| INC D | D = D + 1 | 加一 |
| DEC D | D = D - 1 | 减一 |
| NEG D | D = -D    | 取负 |
| NOT D | D = ~D    | 取反 |

![image-20240506144133551](images/image-20240506144133551.png)

### 二元运算+位运算

第二个操作数同时是源和目的操作数，不能是立即数

| 指令     | 效果       | 描述 |
| -------- | ---------- | ---- |
| ADD S D  | D = D + S  |      |
| SUB S D  | D = D - S  |      |
| IMUL S D | D = D * S  |      |
| XOR      | D = D ^ S  | 异或 |
| OR       | D = D \| S | 或   |
| AND      | D = D & S  | 与   |

![image-20240506144459678](images/image-20240506144459678.png)

### 移位运算指令

| 指令       | 效果                 | 描述     |
| ---------- | -------------------- | -------- |
| `SAL k, D` | D=D<<k               | 左移k位  |
| `SHL k,D`  | 左移没区别           | 左移k位  |
| `SAR k, D` | 算数右移，填入符号位 | 算数右移 |
| `SHR k, D` | D = D >> k           | 逻辑右移 |

> 移位量k：立即数或者寄存器cl中的数
>
> 对w位长的数据值，m=log~2~w，即只看cl的低m位
> 例如，8位目的操作数，m=3

![image-20240506145044782](images/image-20240506145044782.png)

例：`long t1 = z * 48`

相当于`leaq (%rdx, %rdx,2), %rax`
`salq $4, %rax`



![image-20240506145150089](images/image-20240506145150089.png)

### 特殊算数操作...

## 3.6.1.指令与条件码(控制流)

### 条件码寄存器

CPU维护，长度是单个bit

每个时刻存指令

- CF：进位标志，检查无符号数的溢出
- ZF：零标志，操作结果等于0时
- SF：符号标志，最近操作结果小于0
- OF：溢出标志，最近的操作导致正溢出或负溢出

![image-20240622001136838](./images/image-20240622001136838.png)

## 3.6.2跳转指令与循环

跳转指令根据条件寄存器的组合来决定是否进行跳转

p139

![image-20240622001503096](./images/image-20240622001503096.png)

### 条件传送实现条件分支

数据的条件转移代替控制的条件转移:
满足条件，才会移动

![image-20240622101210168](./images/image-20240622101210168.png)

> 为什么基于条件传送的代码比基于跳转指令的代码效率更高？
>
> 现代的处理器通过流水线来获得高性能，遇到跳转指令，处理器根据分支预测器猜测跳转指令是否执行，猜测错误时导致程序性能下降。

### 跳转指令的目标如何编码

编码=目标地址-下一条指令地址





### 循环

条件测试和跳转组合实现循环

### do-while

```assembly
```







### while 

1. 跳转到中间，即先跳转到test，满足再跳转到loop

    ```assem
    goto test;
    loop:
    	body
    test:
    	t=test-expr
    	if(t) goto loop;
    ```

2. 翻译成do-while，先做判断，不通过就跳过dowhile 
    ```assembly
    t = test-expr
    if(!t) goto done;
    do
    	body-statement
    	while(test-expr);
    done
    ```

### for

用while翻译

> 编译器优化：
>
> 编译器如果发现一定满足初始测试，那么就会把初始测试省略汇编



### switch

根据一个表达式的值进行多重分支

跳转表：长度为n的数组，每个元素都是一个指向代码地址的指针



## 3-7. 过程（函数调用）

### call、ret指令

直接调用：`call 标号`
间接调用：`call *operand`

将调用函数的第一条指令地址写入程序指令寄存器rip中，还将返回地址压入栈

ret指令将返回地址弹出，写入到rip中

> 以函数P调用函数Q为例
>
> 1. P：call Q，P保存返回地址并跳转到Q
> 2. Q取出参数，最后存入返回结果给eax
> 3. Q：ret，从堆栈栈顶取出P的返回地址，并跳转执行后面的指令

### 函数参数传递(数据传送)

参数1到参数6使用对应寄存器（rdi、rsi、rdx、rcs、r8、r9），函数参数大于6，超出部分用栈传递

返回值：%rax

1. 通过寄存器传递：具体名字(位数)取决于参数大小
2. 通过栈传递：数据大小向8的倍数对齐，即分配空间是8的倍数

![image-20240701205231586](./images/image-20240701205231586.png)

### 局部变量内存分配和释放(寄存器使用惯例)

调用者保存寄存器：调用者来保存寄存器值

被调用者保存寄存器：被调用者需要将那些被参数覆盖的寄存器的原本的值保存

如何保存寄存器的值：
`pushq %rbp` `pushq %rbx`保存到栈上
`popq %rbx` `popq %rbp`弹出顺序相反

### x86-64栈帧

函数的栈帧：函数执行需要的存储空间超出寄存器能够存放的大小，就借助栈的空间

- 函数P调用函数Q：将P中下一条指令压入栈中，指明Q结束后的继续执行地址，call实现

查看反汇编代码`gcc -Og -o prog xx.c xx.c` `objdump -d proc`

![image-20240701205329088](./images/image-20240701205329088.png)

### 递归过程

> [!caution]
>
> 递归层数太多，不仅费时，更容易产生栈溢出

## 3-8.数组的分配和访问

### 指针计算

![image-20240622145020196](./images/image-20240622145020196.png)

下标或者取地址：E[2] *(E+2)

### 嵌套数组

行优先排列

$ \& D[i][j] = x_d + L(C*i+j)$

### 定长数组



## 3.9.结构体与联合体

### 地址对齐

> [!NOTE]
>
> 地址对齐原则：
>
> 任何K字节的基本对象的地址必须为K的倍数，
>
> 编译器在字段的地址空间分配时插入间隙，以保证结构体元素满足对齐要求

**重新排列**：

...

**末端填充：**

![image-20240506151424634](images/image-20240506151424634.png)

调整结构体中的字段顺序，看起来可以使一个结构体的所有字段在不插入间隙的情况下就满足了对齐要求。但仅仅这样做是不够的。对于结构体数组来说，数组中第二个结构体可能会不满足地址对齐，这种情况下编译器就会在结构体的末端填充字节。

末端填充原则：看结构体中最大的空间字节数（例如=8），那么结构体的末尾地址必须是8的倍数。

例子：

![image-20240513145241425](./images/image-20240513145241425.png)

### 联合体

与结构体不同，联合体中的所有字段共享统一存储区域，大小取决于最大字段的大小。

应用情况：事先知道2个不同的字段使用是互斥的

## 3-10.缓冲区溢出

栈帧中保存程序执行的重要信息：返回地址，保存的寄存器的值

C语言对数组引用不会进行边界检查，如果对越界的数组写入，就破坏存储在栈中的状态信息

### 代码注入攻击

输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码(exploit code) 
攻击代码的地址覆盖原返回地址。执行ret 指令跳转到攻击代码

### 栈随机化

### 栈破坏检测

栈保护者机制来检测缓冲区越界

金丝雀值：缓冲区和栈保存的状态值之间的 特殊值

 在函数返回前，检测金丝雀值是否被修改来判断是否遭受攻击

### 限制可执行代码区域

