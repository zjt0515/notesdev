## 多字节数据存放规则

(Intel)小端方式：低位字节存放在低地址单元，高位字节存放在相邻的高地址单元

大端方式：高位字节存放在低地址单元，低位字节存放在相邻的高地址单元



### 进位计数值

基数Hex Oct Bin
$$
1010_2=A_{16}\\
1100_2=C_{16}\\
1110_2=E_{16}\\
$$


### 进制转换

###  

有符号数和无符号数

### 真值和机器数

指定数据类型，对应不同的数据格式

不同数据类型，决定了小数点的隐式位置
这就是定点数：整数，与浮点数相反

真值：正负号+进制数绝对值，即机器数所代表的实际值
机器数：数值编码，原码补码等表示法

编码方式：唯一，符号位如何参与运算
整数：定点补码整数
浮点数的尾数：定点原码小数
浮点数的阶码：移码

## 整数表示

### C有/无符号(转换)

| 有符号 | 无符号 | 64位机器字节数 | 32位 |
| ------ | ------ | -------------- | ---- |
| char   |        | 1              |      |
|        |        | 2              |      |
|        |        | 4              |      |
|        |        | 8              | 4    |
|        |        | 4              |      |
|        |        | 8              |      |
|        |        | 8              | 4    |
|        |        | 4              |      |
|        |        | 8              |      |

有符号和无符号转换：底层的位表示不变，还分为显式的强制转换和隐式转换
格式化输出：`%d、%u、%x`

同时包含有符号数和无符号数的运算(包括算术运算和比较运算等等)：将有符号用无符号数解释，并假设2个数都是**非负数** 

```c
(-2147483647-1u < -2147483647) == 1
```

### 位拓展(不同字长数据转换)

无符号转为更长的无符号：零拓展，数值不变

有符号转为更长的有符号：符号位拓展（符号位是几，拓展的位就全是几），数值不变

### 截断数字

数值一般会改变

截断无符号：相当于取模运算

截断有符号：



### 定点数、原码表示法

第一位是符号位，其他位是正常的二进制数值位(加起来是多少就是多少)，与真值相同
$$
真值\rightarrow原码(用十进制计算后进制转换，就是原码表示的机器码)
\\
纯小数：[x]_原=\left\{
\begin{array}{rcl}
x & 0\leq x<1\\
1+\lvert x\rvert & -1<x\leq0
\end{array}\right.
\\
纯整数：[x]_原=\left\{
\begin{array}{rcl}
x & 0\leq x<2^{n-1}\\
2^{n-1}+\lvert x \rvert & -2^n<x\leq0
\end{array}\right.
\\
$$

有符号数：符号位 $-2^{n-1}+1\leftrightarrow2^{n-1}-1$
无符号数：符号位变成数值位$0\rightarrow2^n-1$

> 用原码表示有符号数，只能表示$2^n-1$个数字
>
> 因为$(1000)_2和(0000)_2$都表示的是0



使用原码对有符号数进行加减运算很麻烦

### 原码

对于正负数，原码的区别只在符号位上不一样
0有两种原码表示：$[x]_原=[1/0]0000$​

原码缺点：符号位不能直接参与运算
正数原反补一致
**负数原码->补码**：负数除了符号位全部取反，变成反码，再+1就是补码
**负数补码->原码**：从右往左找到第一个1，1左边**所有数值位**全部取反

![image-20240401081444814](./images/image-20240401081444814.png)

![image-20240401081435335](./images/image-20240401081435335.png)



### 反码

正数：原反补都一致
负数：原码的基础上，除了符号位全部取反

### 补码

计算机底层，通常用补码表示，适合做加减运算
正数：三码都一样
负数：数值位部分计算：绝对值按位取反后末位+1

> (负数)补码的数值为**不能**解读为位权
>
> 负数的补码等于对应正数补码的“各位取反、末位加1：-1 =~ 0001 + 1 = 1111
>
> 负数的补码等于模2^n^-负数的绝对值：-1 = 1 0000-0001 = 1111



### 补码加法 

所有位直接相加即可

### 补码减法

$A-B=A+(-B)$​ 将减法等价为加法

求一个补码的相反数的补码：$B_补\rightarrow-B_补=全部位取反，末位+1$
//$相当于找到最右边的1，1左侧的位全部按位取反$​

### 原反补三码对比

| n+1 bit，以n+1=8，n=7为例，n的大小表示数值位的个数 | 范围               | 描述                               | MAX       | MIN              | 0            |
| -------------------------------------------------- | ------------------ | ---------------------------------- | --------- | ---------------- | ------------ |
| 原码                                               | $[-(2^n-1),2^n-1]$ | 范围对称                           | 0111 1111 | 1111 1111        | 1/0 000 0000 |
| 反码                                               | $[-(2^n-1),2^n-1]$ | 范围对称                           | 0111 1111 | 1000 0000        | 1/0 000 0000 |
| 补码                                               | $[-2^n,2^n-1]$     | (负数)范围比原码范围多1，最小数大1 | 0111 1111 | 1000 0000$=-2^n$ | 0000 0000    |
| 无符号整数                                         | $[0,2^{n+1}-1]$    |                                    | 1111 1111 | 0000 0000        | 0000 0000    |
| 移码                                               | $[-2^n,2^n-1]$     |                                    | 1111 1111 | 0000 0000        | 1000 0000    |

考点：是否发生溢出？带入十进制验证即可，验证是否超出对应范围


$$
[x]_补=
\begin{cases}
x & 0\leq x\lt2^{n-1}-1\\
2^{n}-\lvert x\rvert & -2^{n-1}\leq x \lt 0\\

\end{cases}
$$

对于负数，$[x]_补+[x]_原 = 2^{n}$

>  如果已知一个负数的补码，如何快速求出他的真值
> 根据上述定理，不难得出只要找一个机器码和他加起来等于2^n+1^即可，再用原码的方式翻译该机器码，即$[x]_补=$

### 移码

$补码的基础上符号位取反$

> 移码只能表示整数，通常用于浮点数阶码

### 定点小数

定点整数：原码、反码、补码、移码，小数点隐含在末尾
定点小数：原码、反码、补码，小数点隐含在符号位后面

定点小数的原码反码补码转换：等同于定点整数

定点小数的加减运算：用补码进行计算

| n+1 bit        | 范围                     | MAX       | MIN       | 0    |
| -------------- | ------------------------ | --------- | --------- | ---- |
| 定点整数：原码 | $[-(2^n-1),2^n-1]$       | 0111 1111 | 1111 1111 |      |
| 定点整数：反码 | $[-(2^n-1),2^n-1]$       | 0111 1111 | 1000 0000 |      |
| 定点整数：补码 | $[-2^n,2^n-1]$           | 0111 1111 | 1000 0000 |      |
| 定点小数：原码 | $[-(1-2^{-n}),1-2^{-n}]$ | 0111 1111 | 1111 1111 |      |
| 定点小数：反码 | $[-(1-2^{-n}),1-2^{-n}]$ | 0111 1111 | 1000 0000 |      |
| 定点小数：补码 | $[-1,1-2^{-n}]$          | 0111 1111 | 1000 0000 |      |

位数拓展：位数拓展都是在小数点的后面



## 整数运算

### 无符号加法

```c
// 判定溢出
int uadd_isoverflow(unsigned x, unsigned y){
  unsigned sum = x+y;
  return sum >= x;
  // 发生溢出时，结果小于任何一个数
}
```

无符号求反：除了0之外，相加正好溢出等于0

### 有符号加法 

注：这里对于结果修正的描述，都是对人计算的结果进行修正

负溢出：两个数都有负权重，不考虑其他位的进位，负权重抵消，相当于结果加上2^w
正溢出：进位到最高位变成了负权重，新增了负权重，相当于结果减去2^w



以4位二进制为例$-2^{3}<=x<=2^3-1$
$$
x+y=\left\{
\begin{aligned}
x+y-2^4& &x+y>=2^3 \\
x+y& &-2^3<=x+y<=2^3-1 \\
x+y+2^4&&x+y<-2^3\\

\end{aligned}
\right.
$$

### 无符号乘法

$$
x*y=(x*y)mod\ 2^w
$$



### 有符号乘法



### 乘以常数

将乘法转化为移位和加减法的组合：

乘以任意整数：将整数用$2^k$的加减形式表示，$结果=x<<k的加减形式$
例如$55=2^6-2^3-2^0$，$x*55=(x<<6)-(x<<3)-x$
注：移位运算级低于加减法

### 除以2^k^

转化为

## 浮点数

### 从科学计数法理解浮点数

定点数表示的数字范围有限，也不能无限制增加数据长度

阶码：阶符+数值部分，阶符代表小数点前移还是后移，数值是移动多少位
尾数：数符+数值部分，数符表示正负，数值表示精度

![image-20240407083100306](./images/image-20240407083100306.png)

### 浮点数表示

1. 阶码和尾数都用原码
2. 阶码和尾数都用补码
3. 混合

#### 阶码和尾数都用原码



### 阶码和尾数都用补码

阶码E：补码或移码表示的定点整数
尾数M：原码或补码表示的定点小数

$N=r^E*M，二进制中r=2$

阶码E反映了浮点数的表示范围，即小数点的实际位置
尾数M的数值部分的位数n反映浮点数的精度

![image-20240407083907366](./images/image-20240407083907366.png)

用8位存不下b的9位，引出下面的问题

### 浮点数尾数的规格化

这里不考虑小数点的移动，默认小数点在？移动通过数值左移或者右移实现

规格：**尾数数值部分的最高位不是0**
左规：尾数算数左移一位，阶码-1
右规：双符号位为01或10则尾数发生溢出，双符号位中的高位是正确的符号位，尾数算数右移(新的符号位与正确的符号位保持一致)，阶码+，注意移位的时候只有低位符号位和数值部分右移

规格化浮点数的尾数

| 尾数表示方法 | 形式       | 最大值 | 最小值 | 范围 | 描述                              |
| ------------ | ---------- | ------ | ------ | ---- | --------------------------------- |
| 原码，正数   | 0.1XXX     | 0.1111 | 0.1000 |      |                                   |
| 原码，负数   | 1.1XXX     | 1.1000 | 1.1111 |      |                                   |
| 补码，正数   | 和原码一样 |        |        |      |                                   |
| 补码，负数   | 1.0XXX     | 1.0111 | 1.0000 |      | 数值最高位为0换成原码后符合规格化 |

## IEEE 754标准浮点数

$$
V=(-1)^S*M*2^E
$$

float：

1. 一位符号位(31位)：
2. 八位阶码E(30-23)：数值决定浮点数类型，长度决定偏置量bias
3. 二十三位尾数M(22-0)：小数字段，权重是小数！

$$
bias=2^{length(E)-1}-1\\
$$



### 规格化值

E不全为0或1，即`e!=0&&e!=255`

E的大小：`E=e-bias`
$$
E=e-bias\\
M=1+f\\
V=
$$


### 非规格化值

E全为0，即`E=0`

1. 表示0的数字：s=0,M=f=0，V=+0，s=1,V=-0
2. 可以表示非常接近0的数：

$$
E=1-bias\\
M=f\\
V=M*2^E
$$



### 特殊值

E全为1，即`E=255`

1. 表示Inf，M=f=0
    1. V=+∞：s=0
    2. V=-∞：s=1
2. 表示NaN，M=f!=0  



### 将int转为float

1. int 12345 = 11 0000 0011 1001 = 1. 1 0000 0011 1001 * 2^13^
2. 计算

### 舍入

向上舍入：朝值更大的方向

向下舍入：朝值更小的方向

向零舍入：..

向偶数舍入：

### 浮点数运算

浮点数加法不具有结合性(由于计算结果可能发生溢出，或者由于舍入而失去精度)

`3.14+1e10-1e10=0.0`



`1e20*1e20*1e-20=+∞`



`1e20*1e20-1e20*1e20=NaN`

### C语言中的浮点数

int、float、double转换

1. int->float：不会溢出，可能会丢失精度
2. int/float -> double：可以
3. double -> float：溢出或舍入
4. flloat / double -> int：向零舍入或发生溢出
