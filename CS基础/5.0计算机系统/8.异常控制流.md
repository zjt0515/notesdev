## 异常



## 进程与上下文

### 地址空间

假象

1. 程序独占的使用处理器
2. 独占的使用内存系统

> 并发流：一个逻辑流的执行在时间上与另一个流重叠的情况，他们是并发运行  
>
> 并行：两个进程在不同核心？上同时运行
>
> 并发是交替运行，并行是同时运行

`/proc`内核相关的数据结构

### 模式

### 上下文

进程调度：进程

进程抢占

> 程序：代码和数据，运行时以段的形式存在于地址空间
>
> 进程：执行中的程序的实例

### fork()

产生一份和父进程具有相同但独立的地址空间

- 相同：
- 独立： 

1. 在父进程返回 子进程的pid (总是 > 0)
2. 在子进程返回 0

### 





## 信号

运行内核和进程 中断其他进程

信号提供了机制：通知进程发生了什么异常情况

支持信号：

| Num  | Name | event |
| ---- | ---- | ----- |
| 1    |      |       |
| 2    |      |       |
| 3    |      |       |

### 信号传送过程

> 进程组：
>
> 每个进程只属于一个进程组
> 每个进程组有唯一ID标识，正整数
>
> ```c
> #include <unistd.h>
> // 获取id
> pid_t getpgrp(void);
> // 改变进程组，原来的进程组id → 更改后的进程组id
> pidt_t setpgrp(pid_t pid, pid_t pgid);
> // pid=15213，创建新进程组15213，包含的进程id也是15213
> setpgid(0,0)
> ```
>
> 子进程和父进程属于一个进程组，
>
> 前台进程组: 
>
> `ls | sort` ls和sort两个进程通过管道连接
>
> 最多有一个前台作业和任意个后台作业
>
> `ctrl+c`终止前台作业
>
> `ctrl+z`挂起前台作业

信号发送：

1. `/bin/kill -9 15213`向15213进程发送信号9（杀死进程
2. `/bin/kill -9 -15213`向进程组15213发送信号9
3. `ctrl+c/z...`
4. `函数kill(pid_t,)`
5. `alarm(unsigned int secs)`，secs秒后发送一个SIGALRM信号给调用进程



接受信号：

1. 进程终止
2. 进程终止并转储内存
3. 进程挂起，直到被SIGCONT信号重启
4. 进程忽略该信号

> 待处理信号：发出而没有被接受的信号
>
> 一个待处理信号最多只能被接受一次