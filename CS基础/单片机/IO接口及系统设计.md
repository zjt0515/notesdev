# IO接口+接口设计

> MCS-51的I/O接口形式主要分两类：
> l 通过并行端口（P0~P3）直接完成输入输出
> Ø单片机并行接口内部结构可参阅第二章；
> Ø单片机通过执行指令MOV A,Px完成端口输入；
> Ø单片机通过执行指令MOV Px,A完成端口输出；
> Ø单片机还可以通过位操作指令完成Px端口中针对某位的输入
> 输出；
> l 通过系统总线扩展完成输入输出
> Ø单片机总线扩展操作时序可参阅第二章；
> Ø单片机通过执行指令MOVX A,@DPTR完成总线输入；
> Ø单片机通过执行指令MOVX @DPTR,A完成总线输出。

## 键盘及其接口设计

> 键盘的基本工作原理
> l 按键一般通过机械触点实现通断
> l 单片机通过I/O端口输入触点状态判断按键的状态
> l 按键按下及弹起时会有抖动现象
>
> <img src="./images/image-20250104130833246.png" alt="image-20250104130833246" style="zoom: 50%;" />
>
> 对抖动现象的处理方法：
> Ø使用如图所示「方案选单」成本高，体积大）；
> Ø使用软件消抖（电路简化，软件复杂度提高）；
> Ø使用专用集成电路。

### 独立式键盘

![image-20250104131017695](./images/image-20250104131017695.png)

![image-20250104131024607](./images/image-20250104131024607.png)



![image-20250104131032601](./images/image-20250104131032601.png)

![image-20250104131038901](./images/image-20250104131038901.png)



### 行列式键盘

 由横跨行线和列线的开关矩阵组成的键盘，行列式键盘可有效节约端口引脚的使用

行列式键盘按键识别原理
l 当行线作为输出，列线作为输入时：
Ø定时控制某根行线输出低电平，且不断循环；
Ø读入所有列线，如果结果不为全1，则有按键按下；
Ø找到读入为0的列，结合目前输出低电平的行，即可判断出
具体的按键位置。

![image-20250104131812937](./images/image-20250104131812937.png)

![image-20250104131725468](./images/image-20250104131725468.png)

程序设计方法

![image-20250104131923820](./images/image-20250104131923820.png)



![image-20250104131933069](./images/image-20250104131933069.png)

![image-20250104132035985](./images/image-20250104132035985.png)

![image-20250104132046838](./images/image-20250104132046838.png)



### 按键接法和去抖方法

1. 独立式键盘 
    电路简单，检测线独立，软件编写简单
    占用较多IO口线

2. 矩阵键盘/行列式键盘

    电路复杂， 软件编写复杂
    占用IO线少

按键去抖方法

> 抖动：
>
> 按键闭合和断开过程有抖动期(一串负脉冲)

1. 软件延时方法，加入延时子程序
2. 硬件方法：采用专门去抖动的硬件电路芯片

可采用如下方法解决按键抖动问题：
(1) 方法1
Ø扫描到按键按下后，等待20ms，再次读入按键状态进行确认。这种方法很方便，但是等待过程CPU不能处理别的事情，浪费了CPU的处理能力。
(2) 方法2
Ø采用定时间隔扫描和异或法判断按键，将间隔值设置成大于抖动时间的值，例如20ms甚至更大，这样即使某次扫描正好处于抖动阶段，也不会对结果产生影响（但会使判断结果延时一次扫描间隔输出）。

### 按键检测程序设计

一个开关k和一个LED检测开关K是否闭合系统

```c
#include <reg51.h>
typedef unsigned char u8;
typedef unsigned int u16;
sbit led = P1^0;
sbit key = P3^0;
// 延时函数
void delay(u16 i){
    while(i--);
}
void main(){
    // 不断检测按键
    while(1){
        if(key == 0){
            delay(1000); // 去抖
            if(key == 0) led = 0; //点亮led
            while(!key); // 判断是否断开
        }
    }
}
```





## 控制发光二极管LED显示

### 数码管显示器的3结构和原理

1. 单个LED的驱动
    1. 通过单片机端口引脚灌电流方式驱动：
    2.  通过单片机端口驱动三极管的方式驱动：
    3. 通过单片机端口驱动专用集成电路的方式驱动：
2. 单个数码管的驱动

![image-20250104132234655](./images/image-20250104132234655.png)



![image-20250104132225679](./images/image-20250104132225679.png)



![image-20250104132301188](./images/image-20250104132301188.png)



![image-20250104132411304](./images/image-20250104132411304.png)

![image-20250104132418533](./images/image-20250104132418533.png)

![image-20250104132433064](./images/image-20250104132433064.png)

![image-20250104132438894](./images/image-20250104132438894.png)



1. 高电平驱动：
2. 低电平驱动：

 例题：

> [!ques]
>
> 控制一个8段共阳极数码管(连接P0口)，要求数码管反复显示单个数字：0-9
>
> ```c
> #include <reg51.h>
> void delay1s();
> // 共阳极数码管 0-9 段码数组
> unsigned char LED[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
> void main(){
>  unsigned char i;
>  // 定时器计数器工作方式
>  TMOD = 0x10;
>  while(1){
>      for(i = 0; i < 10; i++){
>          P1=LED[i]; //P1端口输出段码
>          delay1s(); // 延时1s
>      }
>  }
> }
> // 延时函数 
> void delay1s(){
> 	unsigned char i;
>  for(i = 0; i < 20; i++){
>      TH1=0x3C;
>      TL1=0xb0;
>      TR1=1;
>      while(!TF1);
>      TF1=0;
>  }
> }
> ```
>
> 

### 数码管静态显示和动态显示

静态显示：每个数码管单独占用一个并行IO口

所谓静态显示，就是数码管的各笔划段都由具有锁存能力的I/O端口引脚驱动，CPU将段码写入锁存器后，每个数码管都由锁存器的输出信号持续驱动。直到下一次CPU更新锁存器存储的段码之前，数码管的显示不会改变;
当需要用静态显示的方法驱动多个数码管时，就需要使用多个具有锁存能力的I/O端口，每个端口驱动一个数码管的显示。

优点：显示数据稳定无闪烁，占用PCU时间少
缺点：占用IO口多，功耗大，电路复杂成本高

![image-20250104132535566](./images/image-20250104132535566.png)

数码管的动态驱动
l 所谓动态显示驱动，就是通过软件，间隔固定时间对每一位数码管轮流驱动，使其交替点亮；
l 动态显示驱动利用了人眼的“视觉暂留”现象，只要数码管点亮的间隔小于人眼的视觉暂留时间(约40ms)，人们就会认为数码管是一直点亮的；
l 由于每次驱动只点亮一个数码管，因此驱动电路可大大简化──所有笔划驱动可以同名复接在一起。为了控制数码管轮流点亮，应增加位显示驱动控制线。具体电路如下页图所示：

动态显示：所有数码管的段选线并联，
优点：节省IO口，电路显示简单
缺点：稳定度不如，占用CPU时间更多

![image-20250104132600562](./images/image-20250104132600562.png)

多个共阴型数码管动态显示驱动程序设计

![image-20250104132622339](./images/image-20250104132622339.png)

## 数码管动态显示驱动和按键扫描相结合

l 在进行数码管显示驱动时，位驱动线每次只有一根输出低电平，每隔固定时间（如10ms）移位一次，正好和行列式键盘扫描的逻辑相符；
l 将位驱动线复用为行列式键盘中的输出线，另外再设置和这些输出线相交叉的输入线，即可构成一个行列式键盘，电路如下图所示：

![image-20250104132654283](./images/image-20250104132654283.png)



## 字符点阵LCD显示模块的控制──模拟总线时序驱动

> LCD显示器简介
> l LCD显示器是一种用液晶材料制成的液晶显示器，它具有体积小、功耗低、字迹清晰、无电磁辐射、使用寿命长等优点，因此广泛应用于各种手持式仪器仪表及消费类电子产品等低功耗应用场合中；
> l LCD显示器的显示方式可分为字符点阵显示和图形点阵显示两种；
> Ø字符点阵显示：字符由固定的5×7或5×10点阵构成，输入字符的ASCII码即可显示；
> Ø图形点阵显示：没有固定的字符点阵，所有显示内容通过将点阵数据写入显示RAM构成，点阵数据中的“1”控制LCD显示一个点，“0”不显示，通过点阵的方式描画出字符、图形。
>
> 将LCD显示器、显示控制电路、CPU接口电路以及背光控制电路等装配在一起，就构成了液晶显示模块(LCM)；
> l LCM具有CPU总线接口，可以连接在CPU总线上接受CPU的控制，完成显示工作；
> l 对于没有外部总线扩展的CPU，也可以通过CPU的I/O端口引脚模拟CPU总线时序来操作LCM。

> 1602字符点阵LCM简介
>
> 1602字符点阵LCM有2个显示行，每行显示16个字符，显示控制器为HD44780，通过HD44100进行显示规模的扩展：
>
> ![image-20250104134503086](./images/image-20250104134503086.png)
>
> 1、LCM 1602的内部结构
> l LCM 1602引脚功能：
> ØDB0～DB7为双向数据总线，用于和CPU交换数据；
> ØE为总线周期有效指示，高电平有效；
> ØR/W为读写选择线，CPU送高电平表示对LCM显示控制器进行读操作，送低电平表示对LCM显示控制器进行写操作；
> ØD/�为寄存器选择线，CPU送高电平表示选择LCM的数据寄存器进行操作，送低电平表示对LCM的指令寄存器进行操作；
> ØVEE为对比度调节控制信号，通过改变该引脚上的电压值可控制LCD显示内容的对比度；
> ØVCC和GND为LCM的电源和地。
> 
> LCM 1602的内部寄存器：
> Ø指令寄存器（IR）：用于存储CPU送达的指令代码，主要包括写入控制器的清屏及移动光标指令、设置显示地址指令、设置字形码指令等。IR是一个只写寄存器； 
>Ø数据寄存器（DR）：用于暂存CPU对控制器内部的DDRAM和CGRAM进行读写的数据；
>  Ø忙标志（BF）：当BF=1时，表示HD44780处于内部操作阶段，除了读忙标志指令之外，不接受任何其它指令。CPU在向HD44780发送指令前一定要先判断BF=0才可以继续写入指令；
> 
> 地址计数器（AC）：指定被操作的DDRAM或CGRAM的地址。地址包含在指令里，首先由CPU写入指令寄存器IR，然后转存到地址计数器AC。指令写入控制器时将指明该地址到底是用于DDRAM还是CGRAM；
> Ø当CPU对DDRAM或CGRAM的读写操作完成后，AC将根据自动增量或减量设置自动加1或减1。
> 
> LCM 1602的内部寄存器的控制：ØCPU通过控制D/I和R/W选择要操作的寄存器：
> ![image-20250104134543057](./images/image-20250104134543057.png)
> 
> LCM 1602的内部存储器：
> 
>1. 显示数据存储器（DDRAM）：存放对应位置要显示的数据的ASCII码或字形码。对于1602LCD显示模块，第一行16个显示字符的ASCII码或字形码存放在DDRAM中地址0x00开始的16个单元中，第二行16个显示字符的ASCII码和字形码则存放在DDRAM中地址0x40开始的16个单元中。
> 2. 存放用户自行设计的字符点阵数据。CGRAM可存储8个5×8点阵字符的字形点阵数据，或者4个5×10点阵字符的字形点阵数据。这些字符在HD44780内部的编码从0x00开始排列；
> 3. CGRAM中的点阵数据写入后将一直保持，显示自定义字符时只要将相应的编码写入显示位置对应的DDRAM中即可；
> 4. LCM掉电后CGRAM中的数据不保存，系统断电再开机后必须重新写入。
> 
> LCM 1602的操作时序
> 
>![image-20250104134729552](./images/image-20250104134729552.png)
>  
> ![image-20250104134750631](./images/image-20250104134750631.png)
>
> LCM 1602的控制指令
>
> ![image-20250104134803786](./images/image-20250104134803786.png)
> 
> ![image-20250104134823491](./images/image-20250104134823491.png)
> 
>![image-20250104134834631](./images/image-20250104134834631.png)
> 
>![image-20250104134850816](./images/image-20250104134850816.png)

### 1602字符点阵LCM与单片机的接口程序

```c
#include <reg51.h>
#include <intrins.h>
#define LCM_DI P10
#define LCM_RW P11
#define LCM_E P12
#define LCM_DB P0
unsigned char LCMReadState(void)
{
  unsigned char state;
  LCM_DB = 0xff;// 并行端口必须先置1再读
  LCM_E = 0;// 开始模拟读IR的总线时序
  LCM_DI = 0;
  LCM_RW = 1;
  LCM_E = 1;// E=1，有效总线周期开始
  _nop_();// 延时一个机器周期等待
  // LCM准备好数据
  state = LCM_DB;// 读数据总线
  LCM_E = 0;// E=0，结束总线周期
  return state;
}
```

## 图形点阵LCD显示模块的控制──扩展总线时序驱动

### LCM 12864的内部结构

![image-20250104135012197](./images/image-20250104135012197.png)

LCM 12864的引脚功能
ØDB0～DB7为双向数据总线，用于和CPU交换数据；
ØE为总线周期有效指示，高电平有效；
ØR/W为读写选择线，CPU送高电平表示对LCM进行读操作，送低电平表示对LCM进行写操作；
ØD/I为寄存器选择线，CPU送高电平表示选择LCM的数据寄存器进行操作，送低电平表示对LCM的指令寄存器进行操作；ØVEE为对比度调节端，可控制LCD显示内容的对比度；
ØCS1和CS2：低有效，对LCM内部的两片HD61202U进行片选，CS1有效选择左半屏控制器，CS2有效选择右半屏控制器；

ØVCC和GND为LCM的电源和地。

LCM 12864的内部寄存器及控制
Ø输入/输出寄存器：为CPU和LCM内部显示RAM之间数据传送的暂存器。CPU写入显示RAM的数据首先送到输入寄存器，然后由芯片内部操作过程自动送入显示RAM； 
Ø当满足CS1或CS2有效并且R/W、D/I的组合选择了输入寄存器时，数据总线上的数据将在E信号的下降沿锁存；
Ø输出寄存器用来暂存从显示RAM中读出的数据；
Ø当满足CS1或CS2有效并且R/W、D/I均为1的条件时，存放在输出寄存器中的数据在E为高电平时输出。在E的下降沿，指定地址的数据被锁存在输出寄存器中，同时地址加1。

忙标志：为1时表示HD61202U正在进行内部操作，除了读状态指令外，其余指令都不接受。忙标志在读出数据的D7表示。在输入任何指令前，应确认此位为0。

显示存储器：每一片HD61202U负责驱动64×64点阵的LCD显示器，其内部显示RAM的地址结构如下图所示：

![image-20250104135049479](./images/image-20250104135049479.png)

X、Y地址计数器：X，Y地址计数器是和内部512字节的显示RAM相对应的9bit的计数器。高3位为X地址计数器，低6位为Y地址计数器，根据指令的不同可以分别设置成X地址（页地址）计数器和Y地址（列地址）计数器。X地址计数器只能作为普通的无计数功能的寄存器使用，而Y地址则在CPU对显示数据进行读写操作后自动加1，并在0~63范围内循环。

起始显示行寄存器：指定和LCD的第一行相对应的显示RAM的行号。此寄存器用于显示器的卷屏操作。通过设置起始显示行指令可以将6bit的起始显示行信息写入此寄存器；

Ø显示开关及翻转：通过选择Y1~Y64的开关状态来实现对LCM显示的控制；
Ø在开状态，显示RAM中为1的位会在点阵的对应位置上显示一个点；
Ø在关状态，所有的点都不显示；
Ø此功能通过显示器开/关指令控制。RST=0将显示器设置为关状态；
Ø当前显示状态通过读指令在D5位输出。显示开/关指令不影响显示RAM中的数据。

Ø复位：在LCM加电时将复位引脚（RST）接低将初始化LCM；
Ø所谓初始化是指关闭LCD的显示并将起始显示地址寄存器置0；
Ø当RST=0时，只能对LCM进行读状态操作；
Ø正常工作状态下，只有判断状态字的D4=0（RESET完成）和D7=0
（就绪）时，程序方可输出其它的指令。

CPU通过D/I和R/W操作LCM 12864的内部寄存器：

![image-20250104135153556](./images/image-20250104135153556.png)

### LCM 12864的控制指令

![image-20250104135210366](./images/image-20250104135210366.png)

![image-20250104135220345](./images/image-20250104135220345.png)

LCM 12864和单片机接口电路的工作过程
Ø单片机采用存储器映像方式通过扩展总线操作的方式对其进行控制；
Ø单片机的数据总线（P0.0～P0.7）和LCM的数据总线（D0~D7）直接相连，即直接入单片机的数据总线；
ØLCM的控制信号R/W、D/I、CS1和CS2直接和单片机地址总线中的A8、A9、A10和A11相连，在执行MOVX指令时，设置合适的地址将在A8~A11上产生符合LCM操作要求的控制信号时序；
Ø单片机的RD、WR经与非门U3A后和LCM12864的E相连，保证只有在单片机进行外部RAM读写操作时E才输出高电平，选通LCM。

![image-20250104135300321](./images/image-20250104135300321.png)

### 接口程序示例

```c
#include <reg51.h>
#include <intrins.h>
#define CWADD1 XBYTE[0x0800]
#define CRADD1 XBYTE[0x0A00]
#define DWADD1 XBYTE[0x0900]
#define DRADD1 XBYTE[0x0B00]
#define CWADD2 XBYTE[0x0400]
#define CRADD2 XBYTE[0x0600]
#define DWADD2 XBYTE[0x0500]
#define DRADD2 XBYTE[0x0700]
#define NOP_nop_();_nop_()
unsigned char LCD_Status(unsigned char chip)
{
  unsigned char c;
  if(chip == 0)// 如果读第一个控制寄存器
  c = CRADD1; // 读第一个控制寄存器内容
  else
  c = CRADD2; // 否则读第二个控制寄存
  // 器内容
  NOP;// 延时两个机器周期
  return c;// 返回读出的内容
}
```

## IO端口模拟时序操作扩展设备

> 单片机和外扩器件之间的接口通常分为并行接口和串行接口两种；
> l 单片机不可能包括所有种类的接口控制逻辑，对于不能直接支持的器件接口，通常使用I/O端口，通过程序控制引脚模拟出符合接口操作要求的时序来完成功能；
> l 串行接口占用I/O资源少、扩展方便、灵活，有利于减小系统体积，所以很多芯片使用串行总线和CPU连接；
> l 除了常见的异步串行通信接口之外，串行总线还包括I2C总线、1-Wire总线、SPI总线及串行移位寄存器等等；
> l 本节介绍单片机模拟I2C串行总线接口时序的设计原理。

> I2C串行总线的基本特点 I2C（Inter-Integrated Circuit）是Philips公司推出的串行总线技术，它是在器件之间实现同步串行数据传输的技术，是一种采用两线制（数据线和时钟线）通信的标准总线。
>
> I2C总线主要有以下几个特征：
>
> 1. 数据传输只需要两条通信线：串行数据线（SDA）和串行时钟线（SCL）；
> 2. 总线模式包括主发送模式、主接收模式、从发送模式、从接收模式；
> 3. 每个连接到I2C总线上的器件都必须有唯一的器件地址，通过这个地址，主器件可以对从器件进行寻址；
> 4. 存在冲突检测和仲裁机制以保证数据传输的完整性和稳定性。
> 5. 传输速率高，标准模式下数据传输速率可达100Kbps,快速模式下可达400Kbps，高速模式下可达3.4Mbps；
> 6. 由于总线接口引脚内部采用了漏极开路工艺，所以总线上要接上拉电阻。连接到相同总线上的IC数量只受到总线最大电容负载400pF的限制。
>
> I2C总线可极大简化子系统之间的连接，总线接口驱动集成在器件中，可最大限度地简化结构；
> l 电路的简化可减少电路板面积，提高可靠性，降低成本；
> l 使用I2C总线有利于促进系统的模块化、标准化设计。

### I2C串行总线通信协议

I2C总线传输接口的特性： 

1. 总线由两根双向的数据线和时钟线构成，使用时必须分别通过上拉电阻接VCC；
2. 接入总线的所有器件的输出都必须是漏极开路方式；
3. I2C总线是一个半双工、多主器件总线，即总线上可有多个主控器件；当器件发送数据时即为主器件，接收数据时则为从器件；
4. I2C总线进行数据传送时，每一位数据都与时钟脉冲相对应：时钟线为高时，数据线上必须保持稳定的逻辑电平；只有在时钟线为低时，才允许数据线的电平变化。

I2C总线的时序: 一次完整的I2C总线时序过程由起始信号、从器件地址信号、应答信号ACK、字节数据信号和停止信号等组成；

起始和停止信号：

1. 在I2C总线协议中，起始信号（S）和停止信号（P）都是
    由主器件产生的。起始信号表明一次I2C总线传送的开始，
    停止信号则表明I2C总线通信结束；
2. 当SCL（时钟线）为高电平时，SDA（数据线）由高电平
    到低电平的负跳变被定义为起始信号；SDA（数据线）由
    低电平到高电平的正跳变为停止信号。
3. I2C总线起始信号和停止信号的时序如下图

![image-20250104135624324](./images/image-20250104135624324.png)

器件地址：

1. 接入I2C总线的每个器件都要有唯一的地址。每次发送器发出起始信号后，必须接着发出一个字节的地址信息，以选取连接在总线上的某一从器件；
2. 地址字节用“从器件地址+R/W”表示。该字节的高7位（D7~D1）为器件地址；D0为读写控制位，为1表示主器件后续将读从器件；为0则表示主器件将写从器件；
3. 7位的从器件地址进一步分为固定部分和可编程部分。固定部分为器件标识，在出厂时设置。可编程部分为器件的物理地址，以区分连接在同一I2C总线上的同类器件。

应答信号ACK

1. I2C总线上的发送器发送完地址字节和每一个字节数据后，被寻址的接收器都必须产生一个应答信号；产生该信号的接收器在第9个时钟周期时将SDA线拉低，表示已收到一个8位数据； 
2. 与应答信号相对应的第9个时钟由发送器产生。发送器必须在输出该时钟时释放数据线SDA，使其处于高阻状态，以便接收接收器件送出的应答信号；
3. 若此后接收器在SDA线上输出了低电平应答信号（ACK），表示接收正常，后续将继续接收数据；如果接收器输出高电平的非应答信号（NO ACK），则表示结束本次通信。

![image-20250104135649165](./images/image-20250104135649165.png)

数据字节信号:

1. I2C总线在器件之间传送数据的字节数是没有限制的；
2. 传送的每字节必须是8位，且首先发送数据的最高位；
3. 每个字节数据发完后发送器都必须发送一位应答脉冲，并在该脉冲有效（高）时接收由接收器发回的应答信号；
4. 如果接收器回送ACK，则发送器继续发送后续字节；如果接收器回送NACK，则发送器发出停止信号P后结束数据传送；
5. 数据传送过程中，如果接收器将SCL线拉成低电平，将迫使发送器处于等待状态，接收器释放SCL线后再继续发送过程。

![image-20250104135703796](./images/image-20250104135703796.png)