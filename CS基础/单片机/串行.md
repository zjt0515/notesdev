## C51编程语言基础

数据类型

| 类型 | 关键字        | 位数 | 数据范围 |
| ---- | ------------- | ---- | -------- |
| 整型 | int           | 16   |          |
|      | short         | 16   |          |
|      | long          | 32   |          |
|      | unsigned int  | 16   |          |
|      | u short int   | 16   |          |
|      | u long int    | 32   |          |
| 实型 | float         | 32   |          |
|      | double        | 64   |          |
|      | char          | 8    |          |
|      | unsigned char | 8    |          |

> C51和C语言，多了变量类型和库函数 
>
> 存储结构:
>
> 1. data：直接寻址，128字节
> 2. bdata：
> 3. idata：间接访问呃 
> 4. pdata：片外数据存储区
> 5. xdata：movx@dptr
> 6. code：movx@dptr

```c
```

## 单片机中断

> 中断：终止原程序，转而执行相应的处理程序
>
> 中断实现过程
>
> 1. 请求
> 2. 响应
> 3. 服务
> 4. 返回

### 中断系统

中断源

| 中断源  | 说明 |
| ------- | ---- |
| INT0'   |      |
| 定时器0 |      |
| INT1'   |      |
| 定时器1 |      |
| 串行口  |      |

### 中断请求标志寄存器

1. TCON寄存器
    1. TF1: 溢出中断请求标志位，T1计数产生溢出，TF1置1，响应中断后清零
    2. TF0：溢出中断请求
    3. IE1：外部中断请求1
    4. IE0：外部中断请求0
    5. IT1：选择外部中断请求1为跳沿还是电平触发
    6. IT0: 选择外部中断请求0
2. 串行口控制寄存器SCON
    1. TI：串行口发送中断请求标志位
    2. RI：接受中断请求比奥职位
3. 中断允许寄存器IE：为1允许中断请求，为0禁止中断请求
4. 中断优先级寄存器IP：中断请求源有2个中断优先级，1高0低
    1. PT2：定时器T2中断优先级控制位
    2. PS：串行口中断优先级控制位
    3. PT1：定时器T1
    4. PX1：外部中断1
    5. PT0：定时器T0
    6. PX0：外部中断0
    7. 同级内优先级：外部中断0 > 定时器0 > 外部中断1 > 定时器1 > 串行口 > 定时器2



1. 响应低级中断请求
2. 响应高级中断请求
3. 执行高级中断子程序
4. 执行低级中断子程序

> [!tip]
>
> 单片机复位后，TCON清零，所有中断源的中断请求标志位为0

```c
// 允许T1T0中断，禁止其他中断请求，写出设置IE的相应代码
ES=0; // 禁止串行口中断
EX0=0; // 禁止外部中断0中断
EX1=0;  // 静止外部中断1中断
ET2=0; // 禁止T2中断
ET0=1; // 允许T0 中断
ET1=1; // 允许T1中断
EA=1; // 总中断开放
```

### 中断应用

设计中断服务子程序流程

1. 设置IE，允许相应的中断请求源中断
2. 设置IP，确定使用的中断源优先级
3. 若是外部中断源，设置中断请求的触发方式
4. 编写中断服务子程序



```c
// 定时器中断函数
void Timer0_Routine()interrupt 1
{
  static unsigned  int T0Count;
  TL0 = 0x18;
  TH0 = 0xFC;
  T0Count++;
  if(T0Count >= 1000)
  {
    T0COunt = 0;
  }
}
```

## 定时器/计数器





TMOD：选择TO、T1的工作模式和方式



定时器模式：内部脉冲

计数器模式：外部脉冲，需要2个及以上机器周期

### 寄存器

1. 工作方式控制寄存器TMOD，高4位控制T1，低4位控制T0
    1. GATE门控位：
    2. M1M0工作方式选择位
        1. 00 
        2. 01
        3. 10
        4. 11 禁用定时器1，定时器0变成2个8位定时器
    3. C/T'计数器模式和定时器模式选择位：0定时器1计数器
2. 定时器/计数器控制寄存器TCON
    1. TF1、TF0计数溢出标志位，1溢出0清零
    2. TR1、TR0计数运行控制位，由软件控制，1启动0停止



> 1. 机器周期=6us*12=2us 
> 2. (最大延时时间达不到1s)每隔1ms产生一次中断 

```c
// 时钟频率6MHz，通过定时器0中断控制P2口的8个LED间隔1s闪烁
// 1.计算计数器初值X
#incldue <reg51.h>
// 统计中断次数
chat i = 100;
void main(){
  TMOD = 0x01;
  // 根据定时时间计算初值
  TH0 = 0xee;
  TL0 = 0x00;
  P1 =  0x00;
  
  EA = 1; // 打开总中断
  ET0 = 1; // T0定时器中断打开
  TR0 = 1; // 启动 定时器
  while(1)
  {
    ;
  }
}
// T0 中断程序
void timer0() interrupt 1
{
  TH0 = 0xee;
  TL0 = 0x00;
  i--;
  if(i <= 0){
    P1 = ~P!;
    i = 100;
  }
}
```



> [!tip]
>
> 确定TMOD寄存器初值：
>
> 1.  根据定时器/计数器 确定M1M0、C/T'
>
> 如何设置计数器初值X，定时时间可以为0.1s/0.005s
>
> 1. 定时时间(us)=(2^16^-X) * 12 / 晶体振荡频率，解x即可
> 2.  X化为16禁止，前8位为TH0的值，后8位为TL0的值





## 串行口

> 并行通信与串行通信
>
> 串行：数据字节一位一位在一条传输线上逐个传送，一次传送一位
>
> 并行：多条数据线同时传送数据字节，每一位都需要一条传输线，还需要几条控制信号线 

> 串行通信的方式：
>
> 1. 异步通信：收发双方使用各自的始终控制，省区连接两者的一条同步时钟信号线
>     连接简单容易实现，但要求二者时钟尽可能一致
> 2. 同步通信：采用一个同步时钟，保持位同步关系，传送的字符之间不留间隙，传输数据的位之间距离均为“位间隔”的整数倍
>
> 通信类别：
>
> 1. 单工：只能单向 发送器向接收器发送
> 2. 半双工：可以双向，但是同时只能一个方向
> 3. 全双工：可以同时双向传送数据

### 串行口结构

接受、发送缓冲器SBUF：可同时收发数据，发送缓冲器只能写 ，接受缓冲器只能读

串行口控制寄存器SCON

1. SM0、SM1：控制工作方式
    1. 00 同步移位寄存器
    2. 01 8位异步收发
    3. 10 9位异步收发
    4. 11 9位异步收发
2. SM2 多机通信控制位
3. REN：
4. TB8：发送的第9位数据
5. RB8：接受的第9位数据
6. TI：
7. RI：

| SCON位 | SM0  | SM1  | REN  | TB8  | TB9  | TI                  | RI                  |      |
| ------ | ---- | ---- | ---- | ---- | ---- | ------------------- | ------------------- | ---- |
| 功能   |      |      |      |      |      | 发送中断标志        | 接受中断标志        |      |
|        |      |      |      |      |      | 1发送结束，软件清零 | 1接受结束，软件清零 |      |
|        |      |      |      |      |      |                     |                     |      |

特殊功能寄存器

波特率(bps)：每秒传送的二进制位

PCON

| PCON位 |      |      |      |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|        |      |      |      |      |      |      |      |      |
|        |      |      |      |      |      |      |      |      |
|        |      |      |      |      |      |      |      |      |





## 串行通信

双机通信接线：TXD接另一个RXD，RXD接另一个TXD，GND共同接1个地线

SM0SM1 = 01



### 波特率计算

$$
f_{osc}：晶振频率\\
方式0: \frac {f_{osc}} {12}\\
方式2: \frac {2^{SMOD}f_{osc} } {64}\\
方式1/3: \frac {2^{SMOD}*T1的溢出率}{32}\\
T1的溢出率=\frac {f_{OSC}}{12* (256-TH1)}\\
$$

### 串行通信格式

方式0: D0~D7

方式1: 起始位+ D0~D7 +停止位

方式2/3：起始位 + D0~D8 + 停止位



方式1

数据位由TXD(P3.1)输出，发送一帧信息为10位（1位起始位0，8位数据位，1位停止位）

当CPU执行一条数据写SBUF指令，就启动发送

方式1接收时(REN = 1)，数据从RXD(P3.0)引脚输入

当检测到起始位的负跳变，就开始接收

方式2和方式3，根据通信协议由软件设置TB8，即启动发送/接收，TB8/RB8装入第9位数据

### 题目：单片机串口初始化

> [!ques]
>
> 单片机串口工作方式为1、波特率4800、波特率加倍、使用中断
>
> 编写配置程序/初始化程序
>
> [!ans]
> $$
> 4800=2^{SMOD}*f_{osc}/32*(256-X)*12
> $$
> 波特率加倍: SMOD=1，解得x为8位二进制数, 让TH1=TL1=x
>
> (一般x是好几万，对应16位二进制数，TH1为高8位，TL1为低8位)
>
> ```c
> void UartInit(){
>   SCON=0x50; // 工作方式1  (0101 0000)
>   TMOD=0x20; // 计数器工作方式2(串行通信可以不用。。)
>   PCON=0x80; // 波特率加倍
>   TH1=0xF3; // 计数器初值高8位
>   HL1=0xF3;
>   
>   ES=1; // 打开串口接收中断
>   EA=1; // 打开总中断
>   TR1=1; // 打开定时/计数器
> }
> ```
>
> 使用定时器1，TR1=1
> 定时器0，TR0=1																																																																			

## 显示程序设计

### 控制发光二极管

1. 高电平驱动：
2. 低电平驱动：







### 控制
