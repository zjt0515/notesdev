## 进程调度算法

CPU调度时机，发生在进程状态改变时

1. 运行 → 等待
2. 运行 → 就绪 (抢占式)
3. 等待 → 就绪 (抢占式)
4. 运行 → 终止

算法分类

1. 先来先服务
2. 最短作业优先
3. 高响应比优先
4. 时间片轮转
5. 最高优先级
6. 多级反馈队列



### 先来先服务FCFS

FirstComeFistSeverd先来后到，每次选择就绪队列之首运行，直到进程退出/阻塞，继续选择下一个

> 如果长作业先运行了，不利于后面的短作业，短作业等待时间长
>
> 适用于CPU繁忙型作业系统，不适合IO繁忙型作业系统

### 最短作业优先SJF

ShortestJobFirst，优先选择运行时间最短的进程来运行

> 不利于长作业，如果短作业非常多，长作业迟迟不运行

### 高响应比优先

$$
优先权=\frac{等待时间+要求服务时间}{要求服务器时间}
$$

优先选择响应比优先级最高的进程运行

> 1. 要求服务时间越短，响应比越高，利于短作业运行
> 2. 等待时间越长，响应比越高，兼顾长作业运行

### 时间片轮转

最古老最简单最公平、使用最广

> 时间片：每个进程分配一个固定的时间段。该进程在该时间段中运行，一个时间片一般是20~50ms
>
> 时间片过短：进程上下文切换次数多，cpu效率低
>
> 时间片过长：短作业进程响应变长
>
> 调度：
>
> 时间片结束，进程未运行完毕，CPU调度到队列末尾
> 时间片结束前阻塞/结束，CPU立即切换

每个进程运行的时间片都一样，时间到了没运行完的进程回到队尾

### 最高优先级

> 进程的优先级
>
> 1. 静态优先级：创建时确定一个固定的优先级
> 2. 动态优先级：根据进程动态变化调整优先级
>     1. 运行时间增加，降低优先级
>     2. 等待时间增加，提高优先级

1. 抢占式：就绪队列中出现优先级高的进程，就把当前进程挂起
2. 非抢占式：运行完当前进程，再运行优先级高的进程

### 多级反馈队列

> 多级：多个队列，队列也有优先级，优先级越高时间片越短
>
> 反馈：有新的进程加入到优先级高的队列，立即停止当前进程，运行优先级高的队列

工作过程



## 内存页面置换算法



## 磁盘调度算法

