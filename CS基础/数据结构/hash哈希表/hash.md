# 散列查找

![image-20240117132848275](./images/image-20240117132848275.png)

![image-20240117132859852](./images/image-20240117132859852.png)

数据元素的关键字与其存储地址直接相关 

- 同义词：不同的关键字通过哈希函数映射到同一个值
- 散列函数：H(key) = ...


## 常见的散列函数

散列函数设计目标：让不同关键字的冲突尽可能少

### 除留余数法

设散列表长度为m
`H(key) = key % p，p = max{ p <= m，且p是质数 }`

> 取质数，能让关键字分布更均匀，冲突更少
> 质数的公因子少，
> 散列函数的设计要结合实际的关键字分布特点来考虑

### 直接定址法

H(key) = key 
H(key) = a * key + b

- 计算简单，不会产生冲突
- 适合关键字连续的情况
- 若关键字不连续，空位较多，会造成存储空间的浪费

### 数字分析法

选取数码分布更均匀的若干位作为散列地址

例如电话号码的最后四位，作为散列地址

### 平方取中法

取关键字的平方值的中间几位作为散列地址

- 具体取几位可以看关键字本身各位的分布情况和乘方过程
- 适用于关键字的每位取值都不够均匀


## 处理冲突方法

### 拉链法

将所有同义词存储在一个链表中

平均查找长度ASL

冲突越多，查找效率越低

装填因子a = 表中记录个数 / 散列表长度，装填因子大小直接影响散列表的查找效率
装填因子a == 平均失败查找长度

拉链法优化：链接元素时，保持同一个链表中关键字的有序性

### 开放定址法 

空闲地址既向他的同义词表项开放，又向非同义词表项开放

Hi =  ( H(key) + di ) %  m，m是表长
对于增量di

- 线性探测法
- 平方探测法
- 伪随机序列法

#### 线性探测

d~i~ = 0, 1, 2, 3, 4……

发生冲突后，每次往后探测相邻的下一个单元是否为空。

查找操作：从本该存在的位置开始查找，直到探测到空闲地址或者找到
删除操作：不能简单地将被删结点置空，应该做一个删除标记进行逻辑删除
ASL查找效率分析：自己去分析叭
缺点：很容易造成堆积现象，影响查找效率

#### 平方探测

d~i~ = 0, 1, -1, 4, -4, 9, -9……

当H(key) + di < 0时，需要+m，即Hi =  ( H(key) + di + m ) %  m

查找操作：按照平方探测的位置一个一个查找，直到找到或者不存在

？？tip：使用平方探测时，m必须是可以表示成4j + 3的质数，才能探测到所有位置

#### 伪随机序列

d~i~ = 某个随机序列

#### 双散列法

当第一个散列函数冲突时，用第二个散列函数算出增加的距离

#### 再散列法

除了原始的散列函数，新增几个散列函数。

当冲突产生时，换一个散列函数，依次直到不发生冲突





## 总结

散列查找是典型的空间换时间的算法
只要散列函数设计合理，则散列表越长，冲突概率越低 。