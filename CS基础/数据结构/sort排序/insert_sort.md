# 插入排序

- 原址排序
- 稳定

## 算法流程

排序趟数：$n-1$

从第二个元素开始，将元素按大小顺序插入到左侧
从后向前逐一比较

## 算法代码

### c++

### python

```python
def insert_sort(a):
    for i in range(1, len(a)):
        base = a[i]
        j = i - 1
        while (j >= 0 and base < a[j]):
            a[j + 1] = a[j]
            j -= 1
        a[j + 1] = base


if __name__ == '__main__':
    a = [1, 1, 4, 5, 1, 4]
    insert_sort(a)
    print(a)
```

## 复杂度分析

最好时间复杂度：$O()$
平均时间复杂度：$O(n^2)$
最差时间复杂度：$O(n^2)$

空间复杂度：$O(1)$
是否稳定：稳定

> 尽管插入排序的时间复杂度更高，**但在数据量较小的情况下，插入排序通常更快**。
>
> 这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 �(�log⁡�) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，�2 和 �log⁡� 的数值比较接近，复杂度不占主导地位；每轮中的单元操作数量起到决定性作用。
>
> 实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。
>
> 虽然冒泡排序、选择排序和插入排序的时间复杂度都为 �(�2) ，但在实际情况中，**插入排序的使用频率显著高于冒泡排序和选择排序**，主要有以下原因。
>
> - 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，**冒泡排序的计算开销通常比插入排序更高**。
> - 选择排序在任何情况下的时间复杂度都为 �(�2) 。**如果给定一组部分有序的数据，插入排序通常比选择排序效率更高**。
> - 选择排序不稳定，无法应用于多级排序。
