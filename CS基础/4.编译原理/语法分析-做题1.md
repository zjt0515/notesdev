# LL1

## 消除左递归

### 改写法

1. 找出递归式，写成闭包形式，
    1. 注：(这里闭包形式千万不要跳步写错，可以慢点)
        一个解决办法是：检查闭包内的元素是否是递归式旁边那个元素，而不是 | 隔开的那个元素

2. 引入新的非终结符代替 闭包
3. 定义新非终结符的产生式：右递归，加空串，其实就是刚才被代替的闭包的表示

示例：如`S=Sa=Saa……=Aa*=AS'` `S'=aS'|空`



![image-20240610154812041](./images/image-20240610154812041.png)

![image-20240609211854622](./images/image-20240609211854622.png)

![image-20240609212248478](./images/image-20240609212248478.png)

![image-20240609212518730](./images/image-20240609212518730.png)

## 求非终结符FIRST集

一定要注意非终结符空串的情况

![image-20240610001503635](./images/image-20240610001503635.png)

注：FIRST(A)中不包含空串，因为当FIRST(B)为空串时，FIRST(C)的情况代替了空串的情况，而FIRST(C)是不存在空串的

![image-20240610160537885](./images/image-20240610160537885.png)



## 求产生式右部FIRST集(基于求非终结符的FIRST集)



## 求FOLLOW集（基于First和FOLLOW

求某个非终结符的FOLLOW集，如FOLLOW(X)

FOLLOW{开始符号}的初始化={#}

1. 先看所有产生式的右部，找右部中存在X的，例如$P->XM1M2$
    1. 如果X后面是终结符，直接加入集合，break
    2. 相反，如果X后面是非终结符M
        1. 非终结符不能推出空串，集合加上FIRST(M1)(除了ε)，to1
        2. 非终结符能推出空串，还要加上FIRST(M2)(除了ε)，以此类推......
        3. 如果X右边所有的符号都能推出空串，最后还要将该产生式左部的FOLLOW集加进去

> [!note]
>
> ！！！只有开始符号：FOLLOW(S)中要加上一个#元素1
>
> 所有FOLLOW集都不包含ε，
> 即在加上FIRST集合时，不能加入空串元素

![image-20240629005759163](./images/image-20240629005759163.png)



## 构造LL分析表(以FIRST和FOLLOW为基础)

注：FIRST_S集合是以FIRST和FOLLOW集为基础



1. 求**每个独立产生式右部的FIRST集**，得到FIRST集中的元素（注：如果产生式右部是选择，要拆分选择成两个式子分别求
    1. 表中`(产生式左部，FIRST_S元素)`位置都写上该产生式

2. 对右部FIRST集中存在空串的产生式，求左部的FOLLOW集合
    1. 表中`(产生式左部，FOLLOW元素)`位置都写上该产生式




![image-20240610164738914](./images/image-20240610164738914.png)

![image-20240610170122518](./images/image-20240610170122518.png)





## LL1分析过程

![image-20240610215845985](./images/image-20240610215845985.png)









## 消除文法二义性





## 证明LL1文法

对于以同一非终结符为左部的多个产生式

1. 仅有一边能推出空串
2. 每个产生式的FIRST集的交集为空
3. 如果有一边能推出ε，那么另外一边的FIRST集与FOLLOW(左部)的交集为空

![image-20240619004808478](./images/image-20240619004808478.png)