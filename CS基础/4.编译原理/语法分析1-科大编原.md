![image-20240608191706642](./images/image-20240608191706642.png)

##   第一讲：LL(1)分析算法 (5.1)

线性时间：从左到右扫描一边即可

![image-20240608191918860](./images/image-20240608191918860.png)

### 构建LL(1)分析表

![image-20240608205450686](./images/image-20240608205450686.png)

**FIRST集的不动点算法**

$FIRST(N)$ 从非终结符N开始推导得出的句子，句子开头的所有可能结果

![image-20240608210042517](./images/image-20240608210042517.png)

构造FIRST集算法示例

![image-20240608210656211](./images/image-20240608210656211.png)


使用不动点算法对每个产生式的右部计算FIRST集
即在每个产生式右部添加对应FIRST集

![image-20240608211226469](./images/image-20240608211226469.png)

然后就能构造LL(1)分析表
![image-20240608211634109](./images/image-20240608211634109.png)



### LL(1)分析表中的冲突

判断冲突：两个产生式的右部的FIRST集存在交集

存在冲突，不是LL1文法

![image-20240608212115828](./images/image-20240608212115828.png)



上面的内容没有考虑到 一个非终结符可以推出空串的情况，是一个方便理解的简易版本
下面我们将引出完整算法

---



### 构造一般条件下的LL1分析表

加入可以推出空串的情况



NULLABLE集合：

- a：可以推出空串的非终结符
- b：可以推出 a(的连接) 的非终结符(递归)
    即可以推出已经处于NULLABLE集合元素的 非终结符
- 反之，如果推出的串中存在至少一个终结符，就不是

![image-20240609160204932](./images/image-20240609160204932.png)

NULLABLE的不动点算法

![image-20240609160347792](./images/image-20240609160347792.png)

- foreach：每一轮都对所有产生式进行判断
- 每一轮结束后，检查集合是否发生变化，无变化结束循环

示例

![image-20240609160754184](./images/image-20240609160754184.png)

### FIRST 

借助NULLABLE集合加入存在空串的情况

![image-20240609161017126](./images/image-20240609161017126.png)

![image-20240609161216286](./images/image-20240609161216286.png)

示例(未完成)

![image-20240609161717773](./images/image-20240609161717773.png)

### FOLLOW集的不动点算法

计算一个非终结符跟随集合：能跟在非终结符**直接**后面的元素集合

![image-20240609202434307](./images/image-20240609202434307.png)

示例

 ![image-20240609202846696](./images/image-20240609202846696.png)



### FIRST_S（推广到串）

> 这里的FIRST_S集合不是前面对每个非终结符求FIRST集

计算String（一个产生式）的FIRST_S集

例如$N->b1b2b3b4……$

1. 从左到右遍历产生式右部的元素
    1. 如果是终结符，加入集合，return
    2. 如果是非终结符，将FIRST(M)加入集合
        1. 同时如果M不能推出空串，return
        2. 反之M能够推出空串，遍历右部会继续进行
2. foreach完了，还没有结束，说明N可以为空串，此时最后一步要加上N的FOLLOW集

![image-20240609203101321](./images/image-20240609203101321.png)



### 从FIRST_S到LL1分析表

如果一个FIRST_S中有终结符`d`，对应产生式的左部是`Z`，
那么在表中`(Z,d)`位置填入对应的产生式(或者产生式的序号)

![image-20240609204348831](./images/image-20240609204348831.png)

![image-20240609204822512](./images/image-20240609204822512.png)

##   第二讲：LL(1)的冲突处理 (5.2)

不是LL1文法变成LL1文法

### 处理冲突：消除左递归

LL1文法不能是左递归的
而右递归一般是成立的

![image-20240609205917302](./images/image-20240609205917302.png)

### 处理冲突：提取左公因子

![image-20240609205859516](./images/image-20240609205859516.png)



##   第三讲：LR(0)分析算法 (5.3)









##   第四讲：SLR分析算法 (5.4)









##   第五讲：LR(1)分析算法 (5.5)



##   第六讲：LR(1)分析工具 (5.6)