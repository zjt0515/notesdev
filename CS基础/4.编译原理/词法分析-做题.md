正规文法->正规表达式->转换系统->DFA->化简



![image-20240617205209302](./images/image-20240617205209302.png)



### 利用T形图描述自编译过程

![image-20240615201435419](./images/image-20240615201435419.png)



### 从文法(一般是左/右线性)到状态转换图

分析过程：自顶向下分析，即自终止状态逐步向前分析

左线性文法：

E->Ex：E状态接受一个x到自身
E->Ay：A状态接受一个y到E

B->Bx：B状态接受一个x到自身
B->z：初始状态接受z到B

右线性文法（和左线性相反）：

1. S->bA：S接受一个b到达A
2. B->a：B接受a到达终止状态

![image-20240616230507371](./images/image-20240616230507371.png)

![image-20240611211337184](./images/image-20240611211337184.png)

## 正规表达式->NFA->DFA->化简

### *将正规表达式转化为转换系统(NFA)

> 基础：从正规表达式到转换系统(NFA)
>
> 或、连接、闭包
>
> 注意：
> 或运算不引入新的中间状态
> 连接和闭包运算都引入了新的中间状态
>
> ![image-20240615203047618](./images/image-20240615203047618.png)
>
> TIP：通过上图的右边部分，可以逆向分析（从转换系统到正规表达式）


> [!note]
>
> 一般用S代表初始状态
> 双圈代表终止状态
>
> NFA和DFA的区别：
>
> - NFA：
>
>     - 存在一个符号离开同一个状态的多条边
>
>     - 空串也可以作为标号 (闭包产生了空串的存在)
>
> - DFA：
>
>     - 以某个标号，有且仅有一个离开当前状态的边





### *将转换系统(NFA)转化为等价的确定有穷自动机(DFA)（子集法）

> 概念：
>
> - 状态的空闭包：一个状态通过0个或多个空串能够到达的状态(对一个集合求空闭包，就是对每个元素都求一遍)
>- $move(I,a)$：以集合中状态为出发点，直接能够通过标号a到达的NFA状态集合
> 
>注意：转换系统(NFA)的状态一般以数字命名（除了首尾），状态转换图(DFA)的状态一般以大写字母命名
> 

转换辅助表求解算法步骤：

1. 对状态0求闭包I，重命名为S
2. 求S的$I_x、I_y、I_z$​，出现新状态就新起一行记作一个新的DFA状态，并对他做重复操作
    1. 如何求$I_x$：检查集合$I$中的元素，求能经过x点到达的状态集合$move(I,x)$，再求他的ε闭包，结果集合为$I_x$，

3. 对每个新出现的状态重复动作，直到没有新的状态出现
4. 确定接受状态：包含原来NFA接收状态的就是DFA的接受状态



然后根据新的DFA状态A，例如，如果有Ix，说明A接受x能转换到Ix状态



![image-20240617143333173](./images/image-20240617143333173.png)

例如，表中`(A,Iz)`有集合，就表示状态A经过z到达状态C





### 确定的有穷自动机(DFA)化简(最小化)

1. 将所有状态分为接受状态和非接受状态2组
2. 用所有输入符号逐个考察每个组中的状态,，对于同一个输入符号：
    1. 某个组所有状态都转换到相同组，不可再分
    2. 有状态转换到了多个组，可再分

3. 重复，直到所有组都不可再分
4. 按照新的分组重新画DFA (同一组的用组内所有名字重命名为一个新的状态 )

> 基础：
>
> 状态等价：(不等价就是可区分的)
>
> 条件1：必须同时为终态或非终态，
>
> 条件2：
>
> 1. 2个状态都能扫描任何符号串x到达终态，反之亦然
> 2. 都能扫描任意符号串x到达同一个状态，该状态能到达终态
> 3. 分别到达2个状态，这2个状态是等价的
>
> 终态和非终态是可区分



![image-20240617145656986](./images/image-20240617145656986.png)

> 把图理解一下应该就行了
