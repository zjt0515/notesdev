

## 内存管理

> 内存管理：操作系统对内存划分、动态分配
>
> 1. 内存空间分配和回收
> 2. 地址转换：逻辑地址转换为物理地址
> 3. 内存空间扩充：虚拟存储技术和自动覆盖技术，逻辑扩充
> 4. 存储保护，互不干扰

### 覆盖与交换技术

多程序环境下扩充内存的方法

覆盖：将程序分为多个段，只有常用段常驻内存
对程序员透明，对用户不透明，只用于早期操作系统

1. 内存划分为一个固定区和若干个覆盖区
2. 固定区：常用段
3. 覆盖区：不常用的段

交换：

1. 换出：将处于等待的进程和被CPU剥夺运行权限的进程移出内存，进程状态变为挂起
2. 换入：将准备好竞争CPU的进程移入内存

### 存储管理方法

1. 

| 存储管理方法 | 描述                       | 优点                 |
| ------------ | -------------------------- | -------------------- |
| 分区存储     | 整个进程放在连续的一片内存 |                      |
| 分页存储     |                            | 解决内存碎片问题较好 |
| 分段存储     |                            | 不会产生**内部**碎片 |
| 段页式存储   |                            |                      |



## 连续分配存储

为每个作业分配地址连续的内存单元(将整个进程放在连续的内存空间)

1. 单一连续分配
2. 固定分区分配
3. 动态分区分配

### 单一连续分配

内存分为系统区和用户区

1. 系统区：通常是低地址部分，存放操作系统系统区
2. 用户区：存放用户进程相关数据

内存中只能有一道用户程序，独占整个用户区空间
单用户单任务的操作系统，存在内部碎片，利用率低

### 固定分区分配

最简单的多道程序存储管理
内存划分为多个固定大小的区域，每个分区装入一道作业

分区大小相等

分区大小不同：灵活性，进程
需要建立分区说明表，将分区按大小排列
实现简单，可能无法满足大程序(需要覆盖技术)，无外部碎片，有内部碎片

| 分区号 | 大小/KB | 起始地址 | 状态   |
| ------ | ------- | -------- | ------ |
| 1      | 12      | 24       | 已分配 |
| 2      | 32      | 32       |        |
| 3      | 64      | 64       |        |

### 动态分区分配管理

不预先划分内存，根据进程大小动态建立分区，系统内存分区大小和数目是动态的

空闲分区表和空闲分区链

**动态分区分配算法（查找空闲区算法）**

| 算法                         | 描述                                                         | 空闲分区排列顺序           | 优缺点               |
| ---------------------------- | ------------------------------------------------------------ | -------------------------- | -------------------- |
| FF首次/最先适应              | 从**未分配区表/空闲区链**选择首个满足的                      | 按地址大小递增排列         | 性能好，开销小       |
| NF邻近适应算法(循环首次适应) | 从上次查找结束位置继续查找首个满足的                         | 同上                       |                      |
| BF最佳适应算法               | 从**未分配区表/空闲区链**选择首个满足的                      | 按容量递增形成分区链       | 会产生很多外部碎片   |
| WF最大/最坏适应算法          | 先检查第一个空闲区是否满足，若满足就从该空闲区划分一个与作业大小一致的内存空间，剩余的空闲区仍然留在表中 | 空闲分区按容量递减次序链接 | 不利于后续大进程使用 |



## 分页存储

> 1G=2^30^B
>
> 进程中的块成为页
> 内存中的块：页框/叶帧
> 外存中的块：块
>
> 逻辑地址结构：分为 页号+页内偏移量
> 每块大小和每页大小相同，即页内偏移量=块内偏移量
> $$
> 逻辑地址有效位=页号有效位+页内偏移量有效位\\
> =log_2页面数量+log_2页面大小\\
> 物理地址有效位至少=块号位数+块内偏移位数
> $$
> 
>
> 页号m：页面数量最大为2^m^个，一个进程最多允许2^m^页面
>
> 页**内**偏移量k：页面大小为2^k^，（页面大小一般为2的整数幂）
>
> 页表：存放在内存中，每个进程有一张页表，记录页面在内存对应的物理块号，用于实现动态重定位
> $$
> 求页表长度\\
> 页表长度=项数*页面项大小=页数*地址位数/8 (B/字节)
> $$
> 

> [!tip]
>
> 内存块个数=物理内存大小/页面大小，对应有多少个内存块号，表示成2的n次幂，说明需要有n个二进制位表示，n/8向上取整对应页表项需要多少字节

### 地址变换结构

1. 具有块表的地址变换结构

> 页表寄存器：存放页表起始地址和页表长度

> [!tip]
>
> 1. 缺页中断：页号不存在页表中，但是没有超出作业长度(题目会给出进程长度?/数表格有几行?)
> 2. 越界中断：页号不存在，超过作业长度
>
> 变换过程方法一（适合十进制），逻辑地址：A，页面大小：L
> 注意：这里计算时, 1k=1024 
> $$
> 页号P≈\frac {逻辑地址}{页面大小}=\frac A L(向下取整)\\
> 页框号(块号)：查页表\\
> 块号地址=块号*页面大小\\
> 页内地址=逻辑地址-页号*页面大小\\
> (因为页号是向下取整的，这里就是求一个差值)\\
> 物理地址=块号地址+页内地址
> $$
>
> 1. 检查是否越界  
> 2. 物理地址=`块号*1024+W`
>
> 方法二：通过偏移量
> $$
> 页内偏移量W=逻辑地址\%页面大小=A\%L\\
> $$
> 



###  题目：分页存储求物理地址

> [!ques]
>
> 逻辑地址长度为16位，页面大小4k，求逻辑地址2F6AH的物理地址
>
> | 页号 | 块号 |
> | ---- | ---- |
> | 0    | 3    |
> | 2    | 7    |
> | 5    | 12   |
>
> 1. 求页内地址位数：4k=2^12^，页内地址的位数=12
> 2. 求页号位数：16-12=4
> 3. 逻辑地址2F6A=0010 1111 0110 1010，找到前4位的`页号=2`和后12位的页内地址
> 4. 查表求块号=7，替换逻辑地址的页号即可，物理地址=0111 ~ ~ ~=...H(最后转成16进制)

> [!tip]
>
> 1. 逻辑地址位数=页号位数+页内地址位数，前x位为页号，后y位为页内地址
> 2. 页号的位数：$n=log_2页面数量$
> 3. 页内地址的位数：$n=log_2每页大小(B)$
> 4. 块号的位：$n=log_2内存大小(kb)$
>
> $$
> 逻辑地址=(页号,页内地址)H\\
> 物理地址=块号,页内地址\\
> $$
>
> 







## 分段存储

逻辑地址：段号S+段内偏移量W

段表：每个段表项对应进程的一段，记录该段在内存的起始地址和长度

| 段号 | 段长 | 起始地址 |
| ---- | ---- | -------- |
|      |      |          |
|      |      |          |
|      |      |          |

### 地址变换结构

段表寄存器：存放 段表起始地址F + 段表长度M

逻辑地址A→物理地址E的变换过程：

1. 根据逻辑地址得到S和W
2. 判断段号是否越界`S <= M`
3. 计算F+S*M
4. 检查段内地址是否超过段长``
5. 计算物理地址`E=`

> [!ques]
>
> 支持最大段长：64kb
>
> | 段号 | 段长 | 段起始地址 |
> | ---- | ---- | ---------- |
> | 0    | 512  | 80k        |
> | 1    | 20k  | 50k        |
> | 2    | 12k  | 81k        |
> | 3    | 3k   | 96k        |
> | 4    | 32k  | 10k        |
>
> 求0x47FD5H和0x003FFH的物理地址
>
> 1. 64KB=2^16^，低4位FD5H表示段内地址，高位4表示段号 
> 2. 求出段号，查段长32k=2^15^=1000 0000 0000 0000 = 8000H
> 3. 物理地址=段起始地址+段内地址
>
> 

## 段页式存储管理

## 虚拟内存管理

> 虚拟内存:  用户看到似乎比实际内存大的内存
>
> 只能基于非连续分配技术
>
> 1. 多次性：无需在运行时全部装入内存，可以多次将需要用到的调入内存
> 2. 对换性：代码或数据无需一直常驻内存，允许换入换出
> 3. 虚拟性：逻辑上扩大内存容量，改善内存利用率
>
> 虚拟存储管理机制的理论基础是程序的（ **局部性** ）原理
>
> 

虚拟内存技术实现，离散的分配方式

1. 请求分页存储管理
2. 请求分段存储管理
3. 请求段页式存储管理

### 请求分页存储管理

增加调页和页面置换功能，最常用

请求页面机制：

请求页表项中的字段，

| 页号 | 物理块号 | 状态位P(1/0)         | 访问字段A                                 | 修改位M                                  | 外存地址                     |
| ---- | -------- | -------------------- | ----------------------------------------- | ---------------------------------------- | ---------------------------- |
|      |          | 该页是否已经调入内存 | 记录一段时间内被访问的次数/未被访问的时长 | 在调入内存后是否被修改过                 | 该页在外村的地址（物理块号） |
|      |          |                      | 用于LRU置换算法换出页面                   | 已经被修改，就必须重新写入外存，否则不用 |                              |

地址变换过程



### 页面置换算法

缺页中断次数：页面置换次数+装入次数(物理块个数)

1. OPT最佳置换算法(无法实现)：淘汰未来最长时间内不被访问的页
2. FIFO：淘汰最早进入内存的页面
3. LRU最近最久未使用： 淘汰最近最久时间未访问的页面
4. CLOCK时钟置换算法/最近未用算法： 访问位0/1，最近是否访问过，第一轮淘汰0访问位的，将扫描过的页面访问位改为1
5. 改进型CLOCK：

抖动：页面置换过程中，刚换出的页面又马上换入，刚换入的页面又马上换出
频繁发送抖动的原因：某个进程频繁访问页面数目高于可用的物理页帧数目，可以撤销部分进程减少用到的页面数

### 题目：页面置换算法

FIFO，缺页率：10/12

| 页面走向 | 1    | 2    | 3    | 4    | 5    | 1    | 4    | 1    | 2    | 3    | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 物理页0  | 1    | 1    | 1    | 1    | 5    | 5    | 5    | 5    | 5    | 5    | 4    | 4    |
| 物理页1  |      | 2    | 2    | 2    | 2    | 1    | 1    | 1    | 1    | 1    | 1    | 5    |
| 物理页2  |      |      | 3    | 3    | 3    | 3    | 3    | 3    | 2    | 2    | 2    | 2    |
| 物理页3  |      |      |      | 4    | 4    | 4    | 4    | 4    | 4    | 3    | 3    | 3    |
|          | t    | t    | t    | t    | t    | t    |      |      | t    | t    | t    | t    |

OPT，缺页率：6/12
从当前访问页面向右查看，淘汰最久之后访问的那个页面

| 页面走向 | 1    | 2    | 3    | 4    | 5    | 1    | 4    | 1    | 2    | 3    | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 物理页0  | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 3    | 3    | 3    |
| 物理页1  |      | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    |
| 物理页2  |      |      | 3    | 3    | 5    | 5    | 5    | 5    | 5    | 5    | 5    | 5    |
| 物理页3  |      |      |      | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    |
|          | t    | t    | t    | t    | t    |      |      |      |      | t    |      |      |

LRU，缺页率：9/12
从当前访问页面向左查看，淘汰最久之前访问的那个页面

| 页面走向 | 1    | 2    | 3    | 4    | 5    | 1    | 4    | 1    | 2    | 3    | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 物理页0  | 1    | 1    | 1    | 1    | 5    | 5    | 5    | 5    | 5    | 3    | 3    | 3    |
| 物理页1  |      | 2    | 2    | 2    | 2    | 1    | 1    | 1    | 1    | 1    | 1    | 5    |
| 物理页2  |      |      | 3    | 3    | 3    | 3    | 3    | 3    | 2    | 2    | 2    | 2    |
| 物理页3  |      |      |      | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    | 4    |
| 缺页     | t    | t    | t    | t    | t    | t    |      |      | t    | t    |      | t    |
