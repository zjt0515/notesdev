## 进程

> 进程关键要素
>
> 1. 程序
> 2. 数据和栈
> 3. 进程控制块

进程=状态机

编译器：汇编状态的翻译器

### PCB描述进程(进程的控制结构)

数据结构：进程控制块 process control block

1. 进程的唯一标识
2. 状态：new ready running waiting blocked
3. 进程优先级
4. 资源分配清单
5. cpu相关信息

pcb之间通过链表方式连接：灵活插入删除

![就绪队列和阻塞队列](./images/12-PCB状态链表组织.jpg)

### 上下文切换

一个进程切换到另一个进程的过程
各个进程之间共享cpu资源

### 进程状态

1. (创建)
2. 就绪
3. 运行
4. 阻塞/等待
5. (挂起)：不能立即投入运行的静止状态
6. (结束)

> 进程基本三态模型的状态转换
>
> 1. 就绪 -> 运行：调度新进程运行
> 2. 运行 -> 就绪：**进程用完时间片**/被抢占被中断
> 3. 运行 -> 等待：初始化IO/对资源访问不能进行
> 4. 等待 -> 就绪：申请资源满足/等待的数据到达

![进程五种状态的变迁](./images/8-进程五个状态.jpg)

### 进程控制

创建原语



### `fork()`克隆

创建当前进程运行状态的一个完整克隆(立刻复制状态机)，
同时具有父子关系，可以形成进程树，都可以执行

> 何为完整拷贝：
>
> - 每一个字节的内存
> - 打开的文件
> - 。。。
> - fork失败返回-1
>
> 唯一的区别：fork的返回值不一样（如果返回值被接收了，那么就有不同的一个状态）

如何区分2个状态机？

1. 子进程返回值：0
2. 父进程返回值：子进程的进程号

```c
pid_t fork(void)
```

fork Bomb `:(){:|:&};:`

```bash
:() {
  : | : &
}; :

# bash允许冒号作为Identifier
f() {
  f | f &
}
f
```

检查fork的细节

> [!work]
>
> ```c
> // demo1
> #include <unistd.h>
> #include <stdio.h>
> int main(){
> pid_t x = fork();
> pid_t y = fork();
> printf("%d, %d\n", x, y);
> }
> ```

> [!work]
>
> ```c
> //demo2
> int main(){
>   for(int i = 0; i < 2; i++){
>     fork();
>     printf("Hello\n")
>   }
> }
> ```
>
> 对于循环的语句分析：==循环展开==
>
> ```c
> int main(){、
>   fork();
>   printf("Hello\n")
>   fork();
>   printf("Hello\n")
> }
> ```
>
> printf的缓存模式
>
> 1. 无缓存
> 2. 行缓存
> 3. 满缓存

## 进程API

`wait()`父进程等待子进程运行结束后再返回

### `execve()`

`int execve(const char *filename, char* const argv[], char * const envp[])`

重置状态机，将**当前进程**重置成一个可执行文件描述状态机的初始状态
可以让子进程执行与父进程不同的程序

> unix中实现“创建新状态机”的方式
> fork+execve
>
> ```c
> #include <unistd.h>
> #include <stdio.h>
> 
> int pid = fork();
> if(pid == -1) {
>  perror("fork"); goto fail;
> } else if(pid == 0){
>  // child
>  execve()
> } else {
>  // parent
> }
> ```
>

```c
int main(){
  int x = *(int*)main;
  printf("%x\n", x);
}
```

## 受限直接执行



## 进程调度算法

> 调度指标
>
> 1. $周转时间=完成时间-到达时间$
>     1. 带权周转时间：周转时间/实际运行时间
>
> 2. $$响应时间=首次运行时间-到达时间$$
> 3. $系统吞吐量=单位时间内完成的作业数$
> 4. $CPU利用率=\frac{有效工作T}{T + 空闲等待时间T}$
>
> 优化周转时间：STCF
>
> 优化响应时间：轮转

1. 先进先出FCFS
2. 最短任务优先SJF
3. 最短完成时间优先STCF
4. 轮转RR

| 调度算法         |      |      |
| ---------------- | ---- | ---- |
| FCFS             |      |      |
| SJF              |      |      |
| 优先级           |      |      |
| 高响应比优先调度 |      |      |
| 多级反馈队列     |      |      |



### 先进先出FIFO/FCFS

先运行到达时间早的作业

1. 非抢占
2. 公平
3. 实现简单，开销小
4. 利于长作业和cpu繁忙型作业
5. 不利于短作业和io繁忙型作业



> [!ques]
>
> FIFO
>
> | 作业 | 提交时间 | 运行时间 | 开始时间 | 等待时间 | 完成时间 | 周转时间 | 带权周转时间 |
> | ---- | -------- | -------- | -------- | -------- | -------- | -------- | ------------ |
> | 1    | 8        | 2        | 8        | 0        | 10       | 2        | 1            |
> | 2    | 8.4      | 1        | 10       | 1.6      | 11       | 2.6      | 2.6          |
> | 3    | 8.8      | 0.5      | 11       | 2.2      | 11.5     | 2.7      | 5.4          |
> | 4    | 9        | 0.2      | 11.5     | 2.5      | 11.7     | 2.7      | 13.5         |
>
> SJF(非抢占)
>
> | 作业 | 提交时间 | 运行时间 | 开始时间 | 等待时间 | 完成时间 | 周转时间 | 带权周转时间 |
> | ---- | -------- | -------- | -------- | -------- | -------- | -------- | ------------ |
> | 1    | 8        | 2        |          |          |          |          |              |
> | 2    | 8.4      | 1        |          |          |          |          |              |
> | 3    | 8.8      | 0.5      |          |          |          |          |              |
> | 4    | 9        | 0.2      |          |          |          |          |              |
>
> 高响应比优先
>
> | 作业 | 到达时间 | 运行时间 | 响应比 |      |
> | ---- | -------- | -------- | ------ | ---- |
> | 1    | 8.00     | 2        |        |      |
> | 2    | 8.30     | 0.40     |        |      |
> | 3    | 9.00     | 0.25     |        |      |
> | 4    | 9.30     | 0.30     |        |      |
>
> 





### 最短任务(短作业)优先SJF

### 优先级

> 进程的优先级
>
> 1. 静态优先级：创建时确定一个固定的优先级
> 2. 动态优先级：根据进程动态变化调整优先级
>     1. 运行时间增加，降低优先级
>     2. 等待时间增加，提高优先级

1. 抢占式：就绪队列中出现优先级高的进程，就把当前进程挂起
2. 非抢占式：运行完当前进程，再运行优先级高的进程

> [!ques]
>
> | 作业 | 到达时间 | 所需CPU时间 | 优先数 | 完成时间 | 周转时间 |
> | ---- | -------- | ----------- | ------ | -------- | -------- |
> | A    | 10:00    | 40分钟      | 5      |          |          |
> | B    | 10:20    | 30分钟      | 3      |          |          |
> | C    | 10:30    | 50分钟      | 4      |          |          |
> | D    | 10:50    | 20分钟      | 6      |          |          |
>
> ```mermaid
> ---
> displayMode: compact
> ---
> gantt
> title 甘特图示例
> dateFormat X
> axisFormat %s
> section D
> 
> section C
> 
> section B
> 
> section A
> 
> ```
>
> 





### 高响应比优先

1. 要求服务时间越短，响应比越高，利于短作业运行
2. 等待时间越长，响应比越高，兼顾长作业运行
3. 需要额外资源计算响应比

$$
优先权=\frac{等待时间+要求服务时间(运行时间)}{要求服务时间}
$$

优先选择响应比优先级最高的进程运行

> [!ques]
>
> | 作业 | 到达时间 | 运行时间 |      |      |
> | ---- | -------- | -------- | ---- | ---- |
> |      |          |          |      |      |
> |      |          |          |      |      |
> |      |          |          |      |      |
>
> 

### 最短完成时间优先STCF

向SJF添加抢占 → STCF

每当新工作进入， 确定所有工作中谁的剩余时间最少，然后调度该工作

> 优势：平均周转时间大大提高

### 轮转RR

> 时间片time-slicing： 



### 多级反馈队列

> 多级：多个队列，队列也有优先级，优先级越高时间片越短
>
> 反馈：有新的进程加入到优先级高的队列，立即停止当前进程，运行优先级高的队列

1. 新进程先进入第一级队列，同一级的作业按照FCFS执行对应的时间片大小
2. 走完当前时间片，**未完成的作业进入下一级队列尾部，然后被其他进程抢占**
3. 如果有新进程进入优先级更高的队列，则抢占当前作业，被抢占作业重新放入原队列队尾
4. 进程走完最后一级队列仍然未完成， 重新加入优先级最低的队尾

| 队列 | 时间片 | 优先级 |
| ---- | ------ | ------ |
| 1    | 小     | 高     |
| 2    | 中     | 中     |
| 3    | 大     | 低     |



> [!ques]
>
> 三级反馈队列时间片大小为2，4，8
>
> | 进程 | 到达时间 | 运行时间 | 完成时间 | 周转时间 | 带权周转时间 |
> | ---- | -------- | -------- | -------- | -------- | ------------ |
> | A    | 0        | 7        | 23       | 23       | 23/7         |
> | B    | 5        | 4        | 12       | 7        | 7/4          |
> | C    | 7        | 13       | 30       | 23       | 23/13        |
> | D    | 12       | 9        | 33       | 21       | 21/9         |
>
> ```mermaid
> ---
> displayMode: compact
> ---
> gantt
> title 甘特图示例
> dateFormat X
> axisFormat %s
> section D
> D1: 12, 14
> D2:18,22
> D:30,33
> section C
> C1: 7, 9
> C2:14,18
> C3:23,30
> section B
> B1: 5, 7
> B2: 10, 12
> section A
> A1: 0, 2
> A2: 2, 5
> A2: 9, 10
> A3: 22,23
> ```
>
> 

> [!tip]
>
> 发生抢占的时机
>
> 1. 运行优先级较低的队列时，遇到新的队列加入
> 2. 时间片运行完













## 进程同步

### 进程同步和互斥

> 临界资源：一次只一个进程使用的共享资源，各进程采取互斥方式实现共享，
>
> 属于临界资源的软硬件：打印机磁带机，消息队列/变量/数组/缓冲区
>
> 互斥访问：每次只允许一个进程进入临界区，进入后不允许其他进程进入
>
> 访问临界资源的4部分：
>
> 1. 进入区，检查是否可以进入临界区，若可以，设置访问临界资源的标志(上锁)
> 2. 临界区，进程中访问临界资源的代码
> 3. 退出区，负责解除标志(解锁)
> 4. 剩余区

同步机制的遵循准则：

1. 空闲让进
2. 忙则等待
3. 有限等待，请求访问的进程能在有限时间内进入临界区
4. 让权等待，进程不能进入临界区时，立即释放处理器

> 进程同步(直接制约关系)：，多个进程一起完成某个任务，因为合作需要在某些位置上**协调工作次序**，从而产生制约关系
> 例如P2进程计算y，需要先计算P1进程的x
>
> ```c
> // 示例程序
> Semaphore s = 0; //是否求得x
> P1(){
>   // 求得x
>   x= ...
>   V(s);
> }
> P2(){
>   // 检查是否已求得x
>   P(S);
>   //计算y
>   y=...;
> }
> ```
>
> 
>
> 进程互斥(间接制约关系)：进程A在访问临界区时，B进程必须等待，直到A释放临界资源

## 信号量机制

> 信号量机制，解决互斥和同步问题，只能被两个标准源于wait和signal访问，也叫PV操作
>
> 1. P，--，申请资源
> 2. V, ++, 释放资源
>
> 信号量分为整形信号量
>
> 1. 整型信号量，表示资源数目
>    ```c
>    // 资源数目
>    int S;
>    // 相当于进入区
>    wait(S){ 
>        // 资源不够，等待
>        while(S <=0 );
>        // 资源够，占用
>        S -= 1;
>    }
>    // 退出区
>    signal(S){
>        // 退出
>        S += 1
>    }
>    //不遵循让权等待，会出现忙等
>    ```
>
> 2. 记录型信号量，增加了一个进程链表链接等待该资源的进程
>    ```c
>    typedef struct{
>        // 剩余资源数
>        int value;
>        // 等待队列
>        struct process * L;
>    }semaphore;
>    void wait(semaphore S){
>        S.value --;
>        if(S.value < 0){
>            block(S.L)
>        }
>    }
>    void signal(semaphore *S){
>        S.value++;
>        if(S.value <= 0){
>            wakeup(P);
>        }
>    
>    ```

### 机制1：实现进程互斥

1. 设置互斥信号量**mutex= 1**
2. 每个进程将临界区代码放到P和V原语之间(申请和释放资源)
3. 必须成对、按次序使用PV原语
4. ==**mutex < 0时，绝对值就是等待进入的进程数量**==

```c
semaphore mutex = 1;
p1(){
    P(mutex);
    //临界区代码段
    ...
    V(mutex);
}
p2(){
    P(mutex);
    //...
    V(mutex);
}
```

### 机制2：实现同步

1. 分析需要实现同步关系的地方
2. 设置同步信号量S=0，一般为0，具体问题具体分析
3. 在前操作后执行V操作
4. 在后操作前执行P操作，即**先V后P**，先释放再申请

```c
// 同步信号量，是否生产了资源
semaphore S = 0;
p1(){
    while(1){
      // c1：生产资源，++，释放到系统资源中
   		V(S);      
    }
}
p2(){
    while(1){
      	// c2: 申请资源，--，使用资源
        P(S);
    }
}
// 保证了c1在c2之前执行
```

信号量实现前驱关系：每一对都是一个同步问题
每条边对应一个同步信号量, 例如a12，a23...

> [!tip]
>
> PV操作题目分析步骤
>
> 1. 找同步和互斥关系
> 2. 根据资源设置信号量变量
> 3. 写出代码过程，注意PV操作位置和成对
> 4. 检查代码

### 生产者和消费者问题

> [!tip]
>
> 互斥访问信号量：缓冲区
>
> 2个同步信号量：空闲缓冲区数量、产品数量(占用缓冲区数量)

> 问题：
>
> 1. 缓冲区未满，生产者可以放入产品
> 2. 缓冲区未空，消费者可以取出
> 3. 缓冲区是临界资源，各进程互斥访问
>
> 分析：
>
> 1. 同步关系：缓冲区满时，生产者必须等待消费者提供非满缓冲区；缓冲区空时，消费者必须等待生产者提供非空缓冲区
> 2. 互斥关系，生产者和消费者对缓冲区的存取操作必须互斥
>
> 实现：
>
> 1. 同步：在一个进程中P操作，另一个进程中V操作
> 2. 互斥：在同一个进程中进行PV操作
> 3. 实现互斥的P操作放在实现同步的P操作之后
>
> ```c
> // 互斥信号量: 缓冲区不能同时存取
> semaphore mutex = 1;
> // 同步信号量1，空闲缓冲区数量, 同步信号量2，产品数量
> semaphore empty = n; semaphore full = 0;
> // 生产者进程，不断检查
> producer(){
>     while(1){
>         // 生产产品
>         P(empty); // 占用空闲缓冲区(检查缓冲区空位)
>       
>         // 临界区：访问临界资源的代码段
>       
>       	// 缓冲区上锁 
>         P(mutex)
>         ...// 放入产品
>         // 退出缓冲区
>         V(mutex);
>       	
>       	// 增加产品数量
>         V(full)
>     }
> }
> //  消费者进程
> consumer(){
>   while(1){
>     // 检查缓冲区是否有资源，拿出产品
>     P(full);
>     
>     // 临界区
>     P(mutex);
>   	...// 取走产品 
>     V(mutex);
>     
>     // 释放空闲缓冲区，取走产品
>     V(empty);
>   }
> }
> ```
>



例题1

> [!ques]
>
> 生产者A和B，消费者C，A和C共享缓冲区buffer1，B和C也共享缓冲区buffer2 ，容量都为10
>
> [!ans]
>
> 1. 设置互斥信号量mutex1=1，mutex2=1
> 2. empty1=10，empty2=10，full1=0,full2=0
>
> ```c
> // 2个缓冲区的互斥访问量
> Semaphore mutex1 = mutex2 = 1;
> // 同步访问量
> Semaphore empty1 = empty2 = 10;
> Semaphore full1 = full2 = 0;
> PA(){
>     while(1){
>         // 生产
>         P(empty1); // 判断是否有空，即需要占用一个空位
>         P(mutex1);
>         V(mutex1);
>         V(full1); // 增加产品数
>     }
> }
> PB(){
>     while(1){
>         // 生产
>         P(empty2); // 判断是否有空
>         P(mutex2);
>         V(mutex2);
>         V(full2); // 增加产品数
>     }
> }
> PC(){
>     while(1){
>         // 拿走A
>         P(full1); // 产品数-1
>         P(mutex1);
>         V(mutex1);
>         V(empty1); // 空位+1
>         // 拿走B
>         P(full2); // 产品数-1
>         P(mutex2);
>         V(mutex2);
>         V(empty2); // 空位+1
>     }
> }
> ```
>
> 

### 读者-写者问题

读进程和读进程之间不互斥

读写进程互斥、写写进程互斥

```c
int count = 0; // 读者个数
Semaphore mutex = 1; // 用于互斥访问
Semaphore rw = 1; // 用于读写互斥
writer(){
  while(1) {
    P(rw);
    // 写文件
    V(rw)
  }
}
reader(){
  while(1){
    P(mutex);
    // 首个读者
    if(count == 0){
      P(rw);
    }
    count++
    V(mutex)
  }
}
```



### 哲学家问题

n个哲学家坐圆桌 ，中间摆1根筷子，哲学家可以思考或者进餐

防止饥饿/死锁：将2个取筷子操作变为原子操作，防止中断

```c
// 5根筷子 的互斥访问量
Semaphore chopsticks[5]  = {1,1,1,1,1};
Semaphore mutex = 1;
Pi(){
  while(1){
    // 临界区
    
    P(mutex);
    // 检查左边的筷子，取筷子
    P(chopsitcks[i]);
    // 检查右边的筷子，取筷子
    P(chopsticks[i+1%5]);
    V(mutex);
    // 吃
    V(chopsitcks[i]);
    V(chopsticks[i+1%5]);
  }
}
```



## PV问题

### 单行道问题(半双工)

```c
int cntSN = cntNS = 0; // 数量
Semaphore mutexSN = mutexNS = 1; // 互斥访问信号量
Semaphore bridge = 1; // 桥上锁的信号量
S2N(){
  P(mutexSN);
 	if(cntSN == 0) {
    P(bridge); // 给桥上锁
  }
  cntSN ++;
  V(mutexSN);
  
  // 过桥
  P(mutexSn)
  cntSN --;
  if(cntSN == 0){
    V(bridge);
  }
  V(mutexSN)
}
```

### 取号叫号问题

```c
int i = j = 0; // 取号和叫号值
Semaphore mutex_i = mutex_j = 1;
Consumer(){
  //  进店
  P(mutex_i);
  //取号
  i++ ; 
  V(mutex_i);
}
Seller(){
  while(1){
    P(mutex_j);
    if(j < i){
      // 叫号
      j++;
      V(mutex_j);
    }else {
      V(mutex_j);
    }

  }

}
```



> [!ques]
>
> 3、有一个垃圾分拣机器人系统，拥有两个机器手臂，可分别自动在垃圾箱里面分拣可回收易拉罐和塑料瓶。设分拣系统有二个进程P1和P2，其中P1驱动左臂拣易拉罐；P2驱动右臂拣塑料瓶。规定每个手臂每次只能拣一个物品；当一个手臂在拣时，不允许另一个手臂去拣；当一个手臂拣了一个物品后，必须让另一个手臂去拣。试用信号量和P、V操作实现两进程P1和P2能并发正确执行的程序。
>
> 1. 同步：p1分拣后p2分拣，p2分拣后p1分拣
> 2. 互斥访问：垃圾箱
>
> ```c
> int S1 = S2 = 0; // 易拉罐和塑料瓶数量
> Semaphore mutex = 0; // 垃圾箱互斥访问
> P1(){
>   while(1){
>     // 检查易拉罐数量
>     P(S1);
>     // 给垃圾桶上锁
>     P(mutex);
>     // 分拣易拉罐
>     V(mutex);
>     
>     V(S1);
>   }
> }
> P2(){
>   while(1){
>     // 检查塑料瓶数量
>     P(S2);
>     // 给垃圾桶上锁
>     P(mutex);
>     // 分拣塑料瓶
>     V(mutex);
>     
>     V(S2);
>   }
> }
> ```
>
> 

> [!ques] 生产者消费者问题
>
> 4、桌上有一只空盘子，允许存放一只水果。爸爸可向盘中放苹果和桔子，儿子专等着取盘中的桔子然后吃掉，女儿专等着取盘中的苹果然后吃掉。规定盘子一次只能放一只水果，盘子中水果没有被取走时，爸爸不可放新水果；盘子中没有水果时，女儿和儿子来取水果时将需等待。请用信号量和P、V原语实现爸爸、儿子、女儿3个并发进程的同步。
>
> 1. 互斥访问：无
> 2. 同步信号量: 儿子吃爸爸放的橘子，女儿吃爸爸放的苹果
>
> ```c
> // 同步信号量:苹果数量和橘子数量
> Seamphore s1 = s2 = 0;
> // 空盘子数
> int s0 = 1;
> 
> father(){
>   while(1){
>     // 占用空盘子
>     P(s0);
>     if(放入苹果) P(s1);
>     else if(放入橘子) P(s2);
>   }
> }
> son(){
>   while(1){
>     // 检查是否有橘子
>     P(s2);
> 
>     // 取出橘子，释放空盘子
>     V(s0);
>     //吃橘子
>   }
> }
> daughter(){
>   while(1){
>     // 检查是否苹果
>     P(s1);
> 
>     // 取出苹果，释放空盘子
>     V(s0);
>     // 吃苹果
>   }
> }
> ```



> [!ques]
>
> 5、内存中有一组缓冲区被**多个生产者**进程、**多个消费者**进程共享使用，总共能存放10个数据，生产者进程把生成的数据放入缓冲区，消费者进程从缓冲区中取出数据使用。缓冲区满时生产者进程就停止将数据放入缓冲区，缓冲区空时消费者进程停止取数据。数据的存入和取出不能同时进行，试用信号量及P、V操作来实现该方案。
>
> 1. 同步信号量：数据空位和占位
> 2. 互斥信号量：缓冲区不能同时存取
>
> ```c
> semaphore empty = 10, full = 0;
> semaphore mutex = 1;
> consumeri(){
>   while(1){
>     // 申请数据
>     P(full);
>     
>     P(mutex);
>     // 取出数据
>     V(mutex);
>     
>     // 释放空位
>     V(empty);
>   }
> }
> // 生产数据
> producer(){
>   while(1){
>     // 申请空位
>     P(empty);
>     
>     P(mutex);
>     // 存入数据
>     V(mutex);
>     
>     // 释放数据
>     V(full);
>   }
> }
> ```
>
> 

## 线程

> [!warning]
>
> 进程的不足：
>
> 创建销毁切换进程，系统开销大
>
> 进程同时作为资源分配单位和调度分派单位，限制并发程序提高

> [!note]
>
> 线程：轻量级进程，基本的CPU执行单元，是被系统独立调度和分派的基本单位
>
> 线程是进程中的一个实体，一个进程可包含多个线程
>
> 优点：
>
> 1. 减少并发开销
> 2. 提高系统并发性
> 3. 便于进程通信
>
> 缺点：降低进程安全性，各线程共享进程空间

线程是进程中的一条执行流程

## 死锁

> 死锁：各进程互相等待对方手里的资源，导致各进程阻塞
> 至少有2个及以上进程同时发生阻塞
>
> 饥饿：可能只有一个进程发生饥饿，可能是阻塞态，也可能是就绪态
>
> **产生死锁的4个条件：**
>
> 1. 互斥条件，只有对互斥使用的资源的争抢会导致死锁
> 2. 请求和保持条件，进程已经保持了至少一个资源，又提出了另外已经被占用的新资源请求，此时请求进程阻塞，对已经占有的资源保持不放
> 3. 循环等待条件，存在进程资源的循环等待链（链中的每个进程已占用的资源被下一个进程请求）死锁一定有循环等待，循环等待未必死锁
> 4. 不剥夺条件：进程所获得的资源不能被其他进程抢占

处理死锁（静态预防或者动态避免）：

1. 预防1：破坏死锁的必要条件
    1. 破坏互斥，将只能互斥使用的资源改造为可共享使用，例如SPOOLing 
    2. 破坏请求和保持
    3. 破坏循环等待
    4. 破坏不剥夺，新的资源请求不满足就释放保持的资源
        实现复杂， 反复释放申请增加系统开销，会导致进程饥饿，主动释放可能造成工作失效，适用于易保存恢复的资源
2. 预防2：防止系统进入不安全状态，例如银行家算法
3. 检测和解除：检测机构检测并解除



> [!note]
>
> 饥饿vs死锁
>
> 死锁：永远等待资源的僵局(资源数量有限/并发进程顺序不当)
>
> 饥饿：每个资源占用者都在有限时间内释放占用资源，但申请进程热爱嗯然长时间得不到资源，策略不公平
>
> 防止死锁的最少资源数：设有n个进程，每个进程需要x个资源a，计算机共有y个资源a
> 考虑极端情况：每个进程都占用x-1个资源，只要还有一台空闲，就可以保证所有进程，n(x-1) + 1 = y





###  银行家算法解题

> 1. Available:  当前系统可用的资源数量
> 2. Max：每个进程最多需要的资源数
> 3. Allocation：当前进程占据的资源数
> 4. Need: 每个进程还需要的资源数 = max - allocation
>
> 安全序列：安全进行请求的进程序列，例如`{P0, P1, P2, P3, P4}`
>
> 1. work 在某个进程工作完成后释放资源后，系统的资源数量
> 2. work + allocation 当前进程请求资源释放资源后，系统可用资源数
>
> 算法调度原则：
>
> 1. 进程请求资源request，如果`request > need`，拒绝请求
> 2. 如果request > available，进程等待
> 3. 前两个都不符合，说明可以请求

| 进程 | max   | allocation            | need                 | Available            |
| ---- | ----- | --------------------- | -------------------- | -------------------- |
| P0   | 7 5 3 | 0 1 0                 | 7 4 3                | 3 3 2<br />（2 3 0） |
| P1   | 3 2 2 | 2 0 0 <br />（3 0 2） | 1 2 2<br />（0 2 0） |                      |
| P2   | 9 0 2 | 3 0 2                 | 6 0 0                |                      |
| P3   | 2 2 2 | 2 1 1                 | 0 1 1                |                      |
| P4   | 4 3 3 | 0 0 2                 | 4 3 1                |                      |

求T0时刻的安全性，找到一个安全序列即可

> work：系统现有的剩余资源，一开始显然work = available
>
> 1. 按顺序选择work > need的进程
> 2. 记录该进程对应的need和allocation
> 3. 下一个work=上一个work+allocation
> 4. 回到开始骤重复


| 进程\资源情况 | work   | need  | allocation | work+allocation   | finish |
| ------------- | ------ | ----- | ---------- | ----------------- | ------ |
| p1            | 3 3 2  | 1 2 2 | 2 0  0     | 5 3 2             | T      |
| p3            | 5 3 2  | 0 1 1 | 2 1 1      | 7 4 3             | T      |
| p0            | 7 4 3  | 7 4 3 | 0 1 0      | 7 5 3             | T      |
| p2            | 7 5 3  | 6 0 0 | 3 0 2      | 10 5 5            | T      |
| p4            | 10 5 5 | 4 3 1 | 0 0 2      | 10 5 7（等于sum） | T      |

> [!ques]
>
> P1请求资源(1,0,2)，系统按银行家算法进行检查
>
> [!ans]
>
> 1. request(1,0,2) < need(1, 2, 2)，合法
> 2. request(1, 0, 2) < available(3, 3, 2) 可以请求
> 3. 将p1进程对应的allocation和need，以及available变成请求后的，然后再进行第一问的操作
>
> | 进程\资源情况 | work | need | allocation | work+allocation | finish |
> | ------------- | ---- | ---- | ---------- | --------------- | ------ |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |

> [!tip]
>
> 1. 计算available：根据系统资源总数和各进程allocation
>     $available=sum - \sum allocation$
>
> 2. 完善原表格`max - allocation = need`
>
> 3. 建立新表格
>
>     | 进程                      | work        | all  | need | w+a  | finish? |
>     | ------------------------- | ----------- | ---- | ---- | ---- | ------- |
>     | need < work的(第一个)进程 | available   | 照抄 | 照抄 | 相加 | true    |
>     | need < work的(第一个)进程 | 上一行的w+a |      |      |      | true    |
>     | need < work的(第一个)进程 | 上一行的w+a |      |      |      | true    |
>
>     写出安全序列，说明是否安全
>
> 4. 针对进程的新的请求，判断`request <= need && request <= available`，不成立就结束
>
> 5. `available -= request`，同时对应进程的`need -=request; allocation += request`，将这**3**个状态数据在原表格上修改，然后按照第3步检查安全状`况



