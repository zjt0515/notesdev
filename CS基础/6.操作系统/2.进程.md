## 进程

> 进程关键要素
>
> 1. 程序
> 2. 数据和栈
> 3. 进程控制块

进程=状态机

编译器：汇编状态的翻译器

### 描述进程(进程的控制结构)

数据结构：进程控制块 process control block

1. 进程的唯一标识
2. 状态：new ready running waiting blocked
3. 进程优先级
4. 资源分配清单
5. cpu相关信息

pcb之间通过链表方式连接：灵活插入删除

![就绪队列和阻塞队列](./images/12-PCB状态链表组织.jpg)

### 上下文切换

一个进程切换到另一个进程的过程
各个进程之间共享cpu资源

### 进程状态

1. (创建)
2. 就绪
3. 运行
4. 阻塞/等待
5. (结束)

> 进程三态模型的状态转换
>
> 1. 就绪 -> 运行：调度新进程运行
> 2. 运行 -> 就绪：进程用完时间片/被抢占被中断
> 3. 运行 -> 等待：初始化IO/对资源访问不能进行
> 4. 等待 -> 就绪：申请资源满足/等待的数据到达

![进程五种状态的变迁](./images/8-进程五个状态.jpg)

### `fork()`克隆

创建当前进程运行状态的一个完整克隆(立刻复制状态机)，
同时具有父子关系，可以形成进程树，都可以执行

> 何为完整拷贝：
>
> - 每一个字节的内存
> - 打开的文件
> - 。。。
> - fork失败返回-1
>
> 唯一的区别：fork的返回值不一样（如果返回值被接收了，那么就有不同的一个状态）

如何区分2个状态机？

1. 子进程返回值：0
2. 父进程返回值：子进程的进程号

```c
pid_t fork(void)
```

fork Bomb `:(){:|:&};:`

```bash
:() {
  : | : &
}; :

# bash允许冒号作为Identifier
f() {
  f | f &
}
f
```

检查fork的细节

> [!work]
>
> ```c
> // demo1
> #include <unistd.h>
> #include <stdio.h>
> int main(){
> pid_t x = fork();
> pid_t y = fork();
> printf("%d, %d\n", x, y);
> }
> ```

> [!work]
>
> ```c
> //demo2
> int main(){
>   for(int i = 0; i < 2; i++){
>     fork();
>     printf("Hello\n")
>   }
> }
> ```
>
> 对于循环的语句分析：==循环展开==
>
> ```c
> int main(){、
>   fork();
>   printf("Hello\n")
>   fork();
>   printf("Hello\n")
> }
> ```
>
> printf的缓存模式
>
> 1. 无缓存
> 2. 行缓存
> 3. 满缓存

## 进程API

`wait()`父进程等待子进程运行结束后再返回

### `execve()`

`int execve(const char *filename, char* const argv[], char * const envp[])`

重置状态机，将**当前进程**重置成一个可执行文件描述状态机的初始状态
可以让子进程执行与父进程不同的程序

> unix中实现“创建新状态机”的方式
> fork+execve
>
> ```c
> #include <unistd.h>
> #include <stdio.h>
> 
> int pid = fork();
> if(pid == -1) {
>  perror("fork"); goto fail;
> } else if(pid == 0){
>  // child
>  execve()
> } else {
>  // parent
> }
> ```
>

```c
int main(){
  int x = *(int*)main;
  printf("%x\n", x);
}
```

## 受限直接执行



## 进程调度

> 调度指标
>
> 1. $周转时间=完成时间-到达时间$
>2. $$响应时间=首次运行时间-到达时间$$
> 
>优化周转时间：STCF
> 
>优化响应时间：轮转

### 先进先出FIFO/FCFS

> [!caution]
>
> 缺陷：护航效应，容易导致耗时少的任务被排在耗时多的任务之后

### 最短任务优先SJF



### 最短完成时间优先STCF

向SJF添加抢占 → STCF

每当新工作进入， 确定所有工作中谁的剩余时间最少，然后调度该工作

> 优势：平均周转时间大大提高

### 轮转RR

> 时间片time-slicing： 

## 进程同步

### 进程同步和互斥

> 临界资源：一次只一个进程使用的共享资源，各进程采取互斥方式实现共享，
>
> 属于临界资源的软硬件：打印机磁带机，消息队列/变量/数组/缓冲区
>
> 互斥访问：每次只允许一个进程进入临界区，进入后不允许其他进程进入
>
> 访问临界资源的4部分：
>
> 1. 进入区，检查是否可以进入临界区，若可以，设置访问临界资源的标志(上锁)
> 2. 临界区，进程中访问临界资源的代码
> 3. 退出区，负责解除标志(解锁)
> 4. 剩余区

同步机制的遵循准则：

1. 空闲让进
2. 忙则等待
3. 有限等待，请求访问的进程能在有限时间内进入临界区
4. 让权等待，进程不能进入临界区时，立即释放处理器

> 进程同步(直接制约关系)：，多个进程一起完成某个任务，因为合作需要在某些位置上**协调工作次序**，从而产生制约关系
>
> 进程互斥(间接制约关系)：进程A在访问临界区时，B进程必须等待，直到A释放临界资源

### 信号量机制

> 信号量机制，解决互斥和同步问题，只能被两个标准源于wait和signal访问，也叫PV操作，P操作对应--，V操作对应++
>
> 信号量分为整形信号量
>
> 1. 整型信号量，表示资源数目
>    ```c
>    // 资源数目
>    int S;
>    // 相当于进入区
>    wait(S){ 
>        // 资源不够，等待
>        while(S <=0 );
>        // 资源够，占用
>        S -= 1;
>    }
>    // 退出区
>    signal(S){
>        // 退出
>        S += 1
>    }
>    //不遵循让权等待，会出现忙等
>    ```
>
> 2. 记录型信号量，增加了一个进程链表链接等待该资源的进程
>    ```c
>    typedef struct{
>        // 剩余资源数
>        int value;
>        // 等待队列
>        struct process * L;
>    }semaphore;
>    void wait(semaphore S){
>        S.value --;
>        if(S.value < 0){
>            block(S.L)
>        }
>    }
>    void signal(semaphore *S){
>        S.value++;
>        if(S.value <= 0){
>            wakeup(P);
>        }
>                
>    ```

机制1：实现进程互斥

1. 设置互斥信号量mutex= 1
2. 每个进程将临界区代码放到P和V原语之间(申请和释放资源)
3. 必须成对、按次序使用PV原语
4. **mutex < 0时，绝对值就是等待进入的进程数量**

```c
semaphore mutex = 1;
p1(){
    P(mutex);
    //临界区代码段
    ...
    V(mutex);
}
p2(){
    P(mutex);
    //...
    V(mutex);
}
```

机制2：实现同步

1. 分析需要实现同步关系的地方
2. 设置同步信号量S=0
3. 在前操作后执行V操作
4. 在后操作前执行P操作

```c
semaphore S = 0;
p1(){
    while(1){
        // c1
   		V(S);      
    }
}
p2(){
    while(1){
        P(S);
        // c2
    }
}
// 保证了c1在c2之前执行
```

> [!tip]
>
> PV操作题目分析步骤
>
> 1. 找同步和互斥关系
> 2. 根据资源设置信号量变量
> 3. 写出代码过程，注意PV操作位置和成对
> 4. 检查代码

### 生产者和消费者问题

> 问题：
>
> 1. 缓冲区未满，生产者可以放入产品
> 2. 缓冲区未空，消费者可以取出
> 3. 缓冲区是临界资源，各进程互斥访问
>
> 分析：
>
> 1. 同步关系：缓冲区满时，生产者必须等待消费者提供非满缓冲区；缓冲区空时，消费者必须等待生产者提供非空缓冲区
> 2. 互斥关系，生产者和消费者对缓冲区的存取操作必须互斥
>
> 实现：
>
> 1. 同步：在一个进程中P操作，另一个进程中V操作
> 2. 互斥：在同一个进程中进行PV操作
> 3. 实现互斥的P操作放在实现同步的P操作之后
>
> ```c
> // 互斥信号量
> semaphore mutex = 1;
> //(同步) 同步信号量1，空闲缓冲区
> semaphore empty = n;
> // 同步信号量2，产品数量
> semaphore full = 0;
> producer(){
>     while(1){
>         // 生产产品
>         P(empty); // 占用空闲缓冲区
>         P(mutex)
>         // 放入缓冲区
>         V(mutex);
>         V(full)
>     }
> }
> consumer(){
>     // 拿出产品
>     P(full);
>     P(mutex);
>   	//
>     V(mutex);
>     V(empty); // 释放空闲缓冲区
> }
> ```
>
> 

> [!ques]
>
> 生产者A和B，消费者C，A和C共享缓冲区buffer1，B和C也共享缓冲区buffer2 ，容量都为10
>
> [!ans]
>
> 1. 设置互斥信号量mutex1=1，mutex2=1
> 2. empty1=10，empty2=10，full1=0,full2=0
>
> ```c
> PA(){
>     while(1){
>         // 生产
>         P(empty1); // 判断是否有空，即需要占用一个空位
>         P(mutex1);
>         V(mutex1);
>         V(full1); // 增加产品数
>     }
> }
> PB(){
>     while(1){
>         // 生产
>         P(empty2); // 判断是否有空
>         P(mutex2);
>         V(mutex2);
>         V(full2); // 增加产品数
>     }
> }
> PC(){
>     while(1){
>         // 拿走A
>         P(full1); // 产品数-1
>         P(mutex1);
>         V(mutex1);
>         V(empty1); // 空位+1
>         // 拿走B
>         P(full2); // 产品数-1
>         P(mutex2);
>         V(mutex2);
>         V(empty2); // 空位+1
>     }
> }
> ```
>
> 



> [!ques]
>
> 一座中间桥，每次允许一辆车通过，有2个方向
>
> ```
> int cntNS = cntSN = 0;
> Semaphore mutexNS = mutexSN = 1; // 互斥访问
> Semaphore bridge = 1;
> S2N(){
> 	P(mutexSN);
> 	if(cntSN == 0) P(bridge);
> 	cnt
> }
> ```
>
> 

## 线程

线程是进程中的一条执行流程

## 操作系统对象

操作系统中的对象：字节流/字节序列
文件：有名字的对象

### 文件描述符

文件描述符就是指向操作系统的指针

> Everything is a file
> 操作系统中的对象都可以是文件
> 通过指针可以访问一切
> 对象的访问都需要指针，open,close,r/w,lseek,dup

> windows中的文件描述符
>
> Handle 把手，握把，(句柄)
>

IPC EndPoints

管道：buffer 缓冲区, 读口和写口
