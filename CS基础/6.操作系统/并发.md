## 死锁

> 死锁：各进程互相等待对方手里的资源，导致各进程阻塞
> 至少有2个及以上进程同时发生阻塞
>
> 饥饿：可能只有一个进程发生饥饿，可能是阻塞态，也可能是就绪态
>
> 产生死锁的4个条件：
>
> 1. 互斥条件，只有对互斥使用的资源的争抢会导致死锁
> 2. 请求和保持，进程已经保持了至少一个资源，又提出了另外已经被占用的新资源请求，此时请求进程阻塞，对已经占有的资源保持不放
> 3. 循环等待条件，存在进程资源的循环等待链（链中的每个进程已占用的资源被下一个进程请求）死锁一定有循环等待，循环等待未必死锁
> 4. 不剥夺条件：进程所获得的资源不能被其他进程抢占

处理死锁（静态预防或者动态避免）：

1. 预防1：破坏死锁的必要条件
   1. 破坏互斥，将只能互斥使用的资源改造为可共享使用，例如SPOOLing 
   2. 破坏请求和保持
   3. 破坏循环等待
   4. 破坏不剥夺，新的资源请求不满足就释放保持的资源
      实现复杂， 反复释放申请增加系统开销，会导致进程饥饿，主动释放可能造成工作失效，适用于易保存恢复的资源
2. 预防2：防止系统进入不安全状态，例如银行家算法
3. 检测和解除

###  银行家算法解题

> 1. Available:  当前系统可用的资源数量
> 2. Max：每个进程最多需要的资源数
> 3. Allocation：当前进程占据的资源数
> 4. Need: 每个进程还需要的资源数 = max - allocation
>
> 安全序列：安全进行请求的进程序列，例如`{P0, P1, P2, P3, P4}`
>
> 1. work 在某个进程工作完成后释放资源后，系统的资源数量
> 2. work + allocation 当前进程请求资源释放资源后，系统可用资源数
>
> 算法调度原则：
>
> 1. 进程请求资源request，如果`request > need`，拒绝请求
> 2. 如果request > available，进程等待
> 3. 前两个都不符合，说明可以请求

| 进程 | max   | allocation            | need                 | Available            |
| ---- | ----- | --------------------- | -------------------- | -------------------- |
| P0   | 7 5 3 | 0 1 0                 | 7 4 3                | 3 3 2<br />（2 3 0） |
| P1   | 3 2 2 | 2 0 0 <br />（3 0 2） | 1 2 2<br />（0 2 0） |                      |
| P2   | 9 0 2 | 3 0 2                 | 6 0 0                |                      |
| P3   | 2 2 2 | 2 1 1                 | 0 1 1                |                      |
| P4   | 4 3 3 | 0 0 2                 | 4 3 1                |                      |

求T0时刻的安全性，找到一个安全序列即可

> work：系统现有的剩余资源，一开始显然work = available
>
> 1. 按顺序选择work > need的进程
> 2. 记录该进程对应的need和allocation
> 3. 下一个work=上一个work+allocation
> 4. 回到开始骤重复


| 进程\资源情况 | work   | need  | allocation | work+allocation   | finish |
| ------------- | ------ | ----- | ---------- | ----------------- | ------ |
| p1            | 3 3 2  | 1 2 2 | 2 0  0     | 5 3 2             | T      |
| p3            | 5 3 2  | 0 1 1 | 2 1 1      | 7 4 3             | T      |
| p0            | 7 4 3  | 7 4 3 | 0 1 0      | 7 5 3             | T      |
| p2            | 7 5 3  | 6 0 0 | 3 0 2      | 10 5 5            | T      |
| p4            | 10 5 5 | 4 3 1 | 0 0 2      | 10 5 7（等于sum） | T      |

> [!ques]
>
> P1请求资源(1,0,2)，系统按银行家算法进行检查
>
> [!ans]
>
> 1. request(1,0,2) < need(1, 2, 2)，合法
> 2. request(1, 0, 2) < available(3, 3, 2) 可以请求
> 3. 将p1进程对应的allocation和need，以及available变成请求后的，然后再进行第一问的操作
>
> | 进程\资源情况 | work | need | allocation | work+allocation | finish |
> | ------------- | ---- | ---- | ---------- | --------------- | ------ |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |
> |               |      |      |            |                 |        |

> [!tip]
>
> 1. 计算available：根据系统资源总数和各进程allocation
>    $available=sum - \sum allocation$
>
> 2. 完善原表格`max - allocation = need`
>
> 3. 建立新表格
>
>    | 进程                      | work        | all  | need | w+a  | finish? |
>    | ------------------------- | ----------- | ---- | ---- | ---- | ------- |
>    | need < work的(第一个)进程 | available   | 照抄 | 照抄 | 相加 | true    |
>    | need < work的(第一个)进程 | 上一行的w+a |      |      |      | true    |
>    | need < work的(第一个)进程 | 上一行的w+a |      |      |      | true    |
>
>    写出安全序列，说明是否安全
>
> 4. 针对进程的新的请求，判断`request <= need && request <= available`，不成立就结束
>
> 5. `available -= request`，同时对应进程的`need -=request; allocation += request`，将这**3**个状态数据在原表格上修改，然后按照第3步检查安全状`况
