

## 内存管理

> 内存管理：操作系统对内存划分、动态分配
>
> 1. 内存空间分配和回收
> 2. 地址转换：逻辑地址转换为物理地址
> 3. 内存空间扩充：虚拟存储技术和自动覆盖技术，逻辑扩充
> 4. 存储保护，互不干扰

### 覆盖与交换技术

多程序环境下扩充内存的方法

覆盖：将程序分为多个段，只有常用段常驻内存
对程序员透明，对用户不透明，只用于早期操作系统

1. 内存划分为一个固定区和若干个覆盖区
2. 固定区：常用段
3. 覆盖区：不常用的段

交换：

1. 换出：将处于等待的进程和被CPU剥夺运行权限的进程移出内存，进程状态变为挂起
2. 换入：将准备好竞争CPU的进程移入内存

## 连续分配存储

为每个作业分配地址连续的内存单元

1. 单一连续分配
2. 固定分区分配
3. 动态分区分配

### 单一连续分配

内存分为系统区和用户区

1. 系统区：通常是低地址部分，存放操作系统系统区
2. 用户区：存放用户进程相关数据

内存中只能有一道用户程序，独占整个用户区空间
单用户单任务的操作系统，存在内部碎片，利用率低

### 固定分区分配

最简单的多道程序存储管理
内存划分为多个固定大小的区域，每个分区装入一道作业

分区大小相等

分区大小不同：灵活性，进程
需要建立分区说明表，将分区按大小排列
实现简单，可能无法满足大程序(需要覆盖技术)，无外部碎片，有内部碎片

| 分区号 | 大小/KB | 起始地址 | 状态   |
| ------ | ------- | -------- | ------ |
| 1      | 12      | 24       | 已分配 |
| 2      | 32      | 32       |        |
| 3      | 64      | 64       |        |

### 动态分区分配

不预先划分内存，根据进程大小动态建立分区，系统内存分区大小和数目是动态的

空闲分区表和空闲分区链

动态分区分配算法

1. 首次适应FF算法：
2. 最佳适应BF算法：按容量递增形成分区链，每次分配找第一个能满足的
   会产生很多外部碎片
3. 最大/最坏WF算法：空闲分区按容量递减次序链接，每次找第一个（最大的）
   不利于后续大进程使用
4. 邻近适应NF算法(循环首次适应)



## 分页存储

###  题目：分页存储求物理地址

> [!tip]
>
> 1. 页号的位：$n=log_2页面数量$
> 2. 页内地址占的位：$n=log_2每页大小(B)$
> 3. 块号的位：$n=log_2内存大小(kb)$

## 分段存储



### 