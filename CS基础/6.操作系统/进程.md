## 进程

进程=状态机

编译器：汇编状态的翻译器

### 描述进程(进程的控制结构)

数据结构：进程控制块 process control block

1. 进程的唯一标识
2. 状态：new ready running waiting blocked
3. 进程优先级
4. 资源分配清单
5. cpu相关信息

pcb之间通过链表方式连接：灵活插入删除

![就绪队列和阻塞队列](./images/12-PCB状态链表组织.jpg)

### 上下文切换

一个进程切换到另一个进程的过程
各个进程之间共享cpu资源

### 进程状态

1. 创建
2. 运行
3. 就绪
4. 阻塞
5. 结束

![进程五种状态的变迁](./images/8-进程五个状态.jpg)

### `fork()`克隆

创建当前进程运行状态的一个完整克隆(立刻复制状态机)，
同时具有父子关系，可以形成进程树，都可以执行

> 何为完整拷贝：
>
> - 每一个字节的内存
> - 打开的文件
> - 。。。
> - fork失败返回-1
>
> 唯一的区别：fork的返回值不一样（如果返回值被接收了，那么就有不同的一个状态）

如何区分2个状态机？

1. 子进程返回值：0
2. 父进程返回值：子进程的进程号

```c
pid_t fork(void)
```

fork Bomb `:(){:|:&};:`

```bash
:() {
  : | : &
}; :

# bash允许冒号作为Identifier
f() {
  f | f &
}
f
```

检查fork的细节

> [!work]
>
> ```c
> // demo1
> #include <unistd.h>
> #include <stdio.h>
> int main(){
> pid_t x = fork();
> pid_t y = fork();
> printf("%d, %d\n", x, y);
> }
> ```

> [!work]
>
> ```c
> //demo2
> int main(){
>   for(int i = 0; i < 2; i++){
>     fork();
>     printf("Hello\n")
>   }
> }
> ```
>
> 对于循环的语句分析：==循环展开==
>
> ```c
> int main(){、
>   fork();
>   printf("Hello\n")
>   fork();
>   printf("Hello\n")
> }
> ```
>
> printf的缓存模式
>
> 1. 无缓存
> 2. 行缓存
> 3. 满缓存

## 进程API

`wait()`父进程等待子进程运行结束后再返回

### `execve()`

`int execve(const char *filename, char* const argv[], char * const envp[])`

重置状态机，将**当前进程**重置成一个可执行文件描述状态机的初始状态
可以让子进程执行与父进程不同的程序

> unix中实现“创建新状态机”的方式
> fork+execve
>
> ```c
> #include <unistd.h>
> #include <stdio.h>
> 
> int pid = fork();
> if(pid == -1) {
>  perror("fork"); goto fail;
> } else if(pid == 0){
>  // child
>  execve()
> } else {
>  // parent
> }
> ```
>

```c
int main(){
  int x = *(int*)main;
  printf("%x\n", x);
}
```

## 受限直接执行

## 线程

线程是进程中的一条执行流程

## 操作系统对象

操作系统中的对象：字节流/字节序列
文件：有名字的对象

### 文件描述符

文件描述符就是指向操作系统的指针

> Everything is a file
> 操作系统中的对象都可以是文件
> 通过指针可以访问一切
> 对象的访问都需要指针，open,close,r/w,lseek,dup

> windows中的文件描述符
>
> Handle 把手，握把，(句柄)
>

IPC EndPoints

管道：buffer 缓冲区, 读口和写口
