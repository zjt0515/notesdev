## 进程的地址空间

> 地址空间：操作系统提供的易用的物理内存抽象，运行的程序看到的系统内存，包含运行程序的所有内存状态
>
> 带访问权限的内存段
>
> 存在系统调用可以在运行时修改地址空间
>
> 包含：
>
> 1. 程序的代码
> 2. 栈：保存当前函数调用信息，存储局部变量、传递参数，函数返回值
> 3. 堆：动态分配的、用户管理的内存

早期系统的物理内存：操作系统+当前程序

![image-20241125202749768](./images/image-20241125202749768.png)



只含代码、栈、堆的简易内存模型

![image-20241125204314368](./images/image-20241125204314368.png)

只是一种约定：将堆和栈放在两端，可以实现栈和堆都能增长或收缩（方向相反）

> 虚拟化内存：
>
> 让运行程序认为它被加载到特定地址的内存中，并且具有非常大的地址空间
>
> 虽然事实上不是这样

> 隔离原则：
>
> 隔离实现可靠性，一个实体失败不影响另一个
> 防止进程之间互相伤害

目标：

1. 透明，程序不会感知到内存被虚拟化的事实
2. 效率，时间和空间上
3. 保护

> 补充：你看到的所有地址都不是真的
>
> 程序打印出的地址都是虚拟的地址
>
> 只要操作系统和硬件才知道物理地址

## 入侵地址空间

理解gdb：将另外一个进程的某一个内存，搬动自己的地址空间中

实现一个功能上类似ce的调试器

```c++
```



> [!work]
>
> 





## 地址转换

将虚拟地址转换为物理地址



基础的**假设**模型：

1. 假设地址空间连续地存放在物理内存中
2. 假设地址空间不是很大，小于物理内存大小
3. 假设每个地址空间大小完全一样



**动态重定位**，运行时发生，可以在进程开始后改变其地址空间

基址寄存器: 

界限寄存器: **检查界限**作用，确保进程产生的所有地址都在进程的地址“界限”中

1. 记录地址空间大小，硬件将虚拟地址和基址求和后，检查这个界限
2. 记录地址空间结束的物理地址，硬件将虚拟地址转换到物理地址后检查这个界限

## 内存操作API

内存类型

1. 栈内存，由编译器隐式管理申请和释放，自动内存
2. 堆内存，程序员显示完成，手动内存

### 库调用

malloc 传入要申请的堆空间的字节大小，它成功就返回一个指向新申请空间的指针，失败就返回NULL

```c
// 关于sizeof的细节
int *x = malloc(10 * sizeof(int)); 
printf("%d\n", sizeof(x));  // 4
// 40
int x[10];
printf("%d\n", sizeof(x)); // 40
```

free() 传入malloc返回的指针，释放不再使用的堆内存

分配区域的大小不会被用户传入，而是由内存分配库本身记录追踪。

> [!caution]
>
> 常见错误
>
> 1. 

### 底层操作系统支持

brk，不应该直接使用

mmap，munmap，mprotect修改权限

mmap() 从操作系统获取内存，在状态机状态上增删改一段可访问的内存，建议`man mmap`

```c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>

#define GiB *(1024LL * 1024 * 1024)

int main() {
  volatile uint8_t *p = mmap(NULL, 16 GiB, PROT_READ | PROT_WRITE,
                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);

  printf("mmap: %lx\n", (uintptr_t)p);

  if ((intptr_t)p == -1) {
    perror("cannot map");
    exit(1);
  }
  *(p + 2 GiB) = 1;
  *(p + 4 GiB) = 2;
  *(p + 15 GiB) = 3;
  printf("Read get: %d \n", *(p + 2 GiB));
  printf("Read get: %d \n", *(p + 4 GiB));
  printf("Read get: %d \n", *(p + 15 GiB));
}

```



### 其他调用？？

calloc() 分配内存

## vdso

## 分段

段：地址空间中的一个连续定长区域
例如一个地址空间中显然有一个代码段、一个栈段、一个堆段

使得操作系统能够将不同的段放到不同的物理内存区域



稀疏地址空间：物理内存中大量未使用的地址空间



> 栈和堆之间有一大块空闲空间
>
> 
