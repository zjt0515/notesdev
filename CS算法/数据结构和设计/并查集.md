> 用途
>
> 处理不相交集合的合并问题
>
> 求连通子图、求最小生成树的Kruskal算法、求最近公共祖先

1. 初始化父节点数组`father[i]=i`，即如果`father[i]==i`，说明该节点是祖先，没有上一级节点了，
    这一条件可以作为之后查找的终点。
    注：这里的初始化可以自定义，只要保证其他节点的值不和该条件重复即可，比如-1
2. 查询祖先`int find(int i)`
3. 合并`void union(int i, int j){ fa[find[i]] = fa[j];}`



> 核心1：路径压缩优化
>
> ```c++
> int find(int i){
>   if(fa[i] == i) return i;
>   else{
>     fa[i] = find(fa[i]);//每次查到一个亲节点，就覆盖为新的亲节点，
>     //以后查找该元素的亲节点只会从他开始查找，不会再查找之前的元素了
>     return fa[i];
>   }
> }
> ```
>
> 

> 核心2：按秩合并优化
>
> 

> [!note]
>
> 应用：
>
> 1. 使用unite将具有关系的节点连接起来
> 2. 使用find分别查找2个元素的祖先节点，如果祖先节点相同，说明这两个节点都在该集合内。

## 用法

1. ### 写一个并查集类

    



### [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

```c++
class UnionFind{
private:
    vector<int> parent;
public:
    UnionFind(){
        parent.resize(26);
        for(int i = 0; i < 26; i++){
            parent[i] =i;
        }
    }
    int find(int i){
        if(parent[i] == i) return i;
        else {
            parent[i] = find(parent[i]);
            return parent[i];
        }
    }
    void unite(int i, int j){
        parent[find(i)] = find(j);
    }
};

class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        UnionFind u;
        int n = equations.size();
        for(int i = 0; i < n; i++){
            if(equations[i][1] == '='){
                u.unite(equations[i][0] - 'a',equations[i][3] - 'a' );
            }
        }
        for(int i = 0; i < n; i++){
            if(equations[i][1] == '!'){
                int m = u.find(equations[i][0] - 'a');
                int n = u.find(equations[i][3] - 'a' );
                if(m == n) return false;
            }
        }
        return true;
        
    }
};


```

## 进一步优化

### 哈希表x并查集

当集合元素为字符串时可以使用