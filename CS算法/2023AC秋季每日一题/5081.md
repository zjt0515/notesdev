> 国际象棋在对局时，同一局面连续或间断出现 33 次或 33 次以上，可由任意一方提出和棋。
>
> 国际象棋每一个局面可以用大小为 8×88×8 的字符数组来表示，其中每一位对应棋盘上的一个格子。
>
> 六种棋子王、后、车、象、马、兵分别用字母 k、q、r、b、n、p�、�、�、�、�、� 表示，其中大写字母对应白方、小写字母对应黑方。
>
> 棋盘上无棋子处用字符 `*` 表示。
>
> 两个字符数组的每一位均相同则说明对应同一局面。
>
> 现已按上述方式整理好了每步棋后的局面，试统计每个局面分别是第几次出现。
>
> ![1.png](./images/19_10f8a9a414-1.png)
>
> 注意：判断重复局面仅涉及字符串比较，无需考虑国际象棋实际行棋规则。
>
> #### 输入格式
>
> 输入的第一行包含一个正整数 n�，表示这盘棋总共有 n� 步。
>
> 接下来 8×n8×� 行，依次输入第 11 到第 n� 步棋后的局面。具体来说每行包含一个长度为 88 的字符串，每 88 行字符串共 6464 个字符对应一个局面。
>
> #### 输出格式
>
> 输出共 n� 行，每行一个整数，表示该局面是第几次出现。
>
> #### 数据范围
>
> 1≤n≤1001≤�≤100
>
> #### 输入样例：
>
> ```
> 8
> ********
> ******pk
> *****r*p
> p*pQ****
> ********
> **b*B*PP
> ****qP**
> **R***K*
> ********
> ******pk
> *****r*p
> p*pQ****
> *b******
> ****B*PP
> ****qP**
> **R***K*
> ********
> ******pk
> *****r*p
> p*p*****
> *b**Q***
> ****B*PP
> ****qP**
> **R***K*
> ******k*
> ******p*
> *****r*p
> p*p*****
> *b**Q***
> ****B*PP
> ****qP**
> **R***K*
> ******k*
> ******p*
> *****r*p
> p*pQ****
> *b******
> ****B*PP
> ****qP**
> **R***K*
> ********
> ******pk
> *****r*p
> p*pQ****
> *b******
> ****B*PP
> ****qP**
> **R***K*
> ********
> ******pk
> *****r*p
> p*p*****
> *b**Q***
> ****B*PP
> ****qP**
> **R***K*
> ********
> ******pk
> ******rp
> p*p*****
> *b**Q***
> ****B*PP
> ****qP**
> **R***K*
> ```
>
> #### 输出样例：
>
> ```
> 1
> 1
> 1
> 1
> 1
> 2
> 2
> 1
> ```
>
> #### 样例解释
>
> 第 66、77 步后的局面分别与第 22、33 步后的局面相同。第 88 步后的局面与上图相对应。



## 暴力枚举

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110;

string g[N];//将所有的局面存储到一个一维数组中,

int main(){
    int n;
    cin >> n;
    for(int i = 0; i < n; i ++){
        string line;
        
        for (int j = 0; j < 8; j++){
            //将一局中的8行全部存储到g[i]
            cin >> line;
            g[i] += line;
        }
        
        int cnt = 0;
        
        for(int j = 0; j < i; j ++){
            if(g[j] == g[i]){
                cnt ++;
            }
        }
        cout << cnt + 1 << endl;
    }
    
    return 0;
}
```



## 哈希表

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>

using namespace std;

//数据结构
const int N = 110;
int n;
unordered_map<string, int> cnt;//存每个局面出现的次数， string就是一个局面的整个字符串


int main()
{
    cin >> n;
    
    for(int i = 0; i < n; i ++)
    {
        string g, line;
        
        for(int j = 0; j < 8; j++)
        {
            cin >> line ;
            g += line;
        }
        
        cout << ++ cnt[g] << endl;
    }
    
    return 0;
}
```

